{"hash":"864b42b473fe515eca8a0a63c63dab3f0358fd50e5e92209197238bfd780a5fe","fesm2022":[{"exports":["NgOAuth2PkceModule","OAUTH2_CONFIG_TOKEN","OAUTH2_STORAGE_KEYS","OAuth2AuthGuard","OAuth2CallbackComponent","OAuth2Service","OAuth2StorageService","oauth2AuthGuard","oauth2InterceptorFn","oauth2RoleGuard","oauth2UnauthGuard","provideOAuth2","provideOAuth2WithoutInterceptor"],"facadeModuleId":"E:\\Witspry\\SourceCode\\witspry-auth-ng-client\\dist\\witspry-auth-ng-client\\esm2022\\witspry-auth-ng-client.mjs","isDynamicEntry":false,"isEntry":true,"isImplicitEntry":false,"moduleIds":["E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/models/oauth2-config.model.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/models/oauth2-types.model.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/tokens/oauth2-config.token.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/services/oauth2-storage.service.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/services/oauth2.service.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/interceptors/oauth2.interceptor.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/components/oauth2-callback/oauth2-callback.component.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/guards/oauth2-auth.guard.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/ng-oauth2-pkce.service.mjs","E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/public-api.mjs","E:\\Witspry\\SourceCode\\witspry-auth-ng-client\\dist\\witspry-auth-ng-client\\esm2022\\witspry-auth-ng-client.mjs"],"name":"witspry-auth-ng-client","type":"chunk","dynamicImports":[],"fileName":"witspry-auth-ng-client.mjs","implicitlyLoadedBefore":[],"importedBindings":{"@angular/core":["InjectionToken","*","PLATFORM_ID","Injectable","Inject","signal","inject","Component","makeEnvironmentProviders","NgModule"],"@angular/common":["isPlatformBrowser","CommonModule","*"],"rxjs":["BehaviorSubject","throwError"],"@angular/common/http":["*","HttpHeaders","HttpRequest","HttpResponse","provideHttpClient","withInterceptors"],"@angular/router":["*","Router"],"rxjs/operators":["catchError","filter","switchMap","take","map"]},"imports":["@angular/core","@angular/common","rxjs","@angular/common/http","@angular/router","rxjs/operators"],"modules":{"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/models/oauth2-config.model.mjs":{"code":"","originalLength":2617,"removedExports":[],"renderedExports":[],"renderedLength":0},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/models/oauth2-types.model.mjs":{"code":"/**\n * OAuth2 Storage Keys Constants\n */\nconst OAUTH2_STORAGE_KEYS = {\n    CODE_VERIFIER: 'oauth2_code_verifier',\n    STATE: 'oauth2_state',\n    ACCESS_TOKEN: 'oauth2_access_token',\n    REFRESH_TOKEN: 'oauth2_refresh_token',\n    TOKEN_EXPIRES_AT: 'oauth2_token_expires_at',\n    TOKEN_TYPE: 'oauth2_token_type',\n    SCOPE: 'oauth2_scope',\n    ID_TOKEN: 'oauth2_id_token',\n    NONCE: 'oauth2_nonce'\n};","originalLength":5241,"removedExports":[],"renderedExports":["OAUTH2_STORAGE_KEYS"],"renderedLength":399},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/tokens/oauth2-config.token.mjs":{"code":"/**\n * Injection token for OAuth2 configuration\n */\nconst OAUTH2_CONFIG_TOKEN = new InjectionToken('OAUTH2_CONFIG');","originalLength":962,"removedExports":[],"renderedExports":["OAUTH2_CONFIG_TOKEN"],"renderedLength":116},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/services/oauth2-storage.service.mjs":{"code":"/**\n * OAuth2 Storage Service\n * Handles secure storage and retrieval of OAuth2 tokens and data\n */\nclass OAuth2StorageService {\n    constructor(config, platformId) {\n        this.config = config;\n        this.platformId = platformId;\n        this.logLevel = config.logLevel || 'warn';\n        this.storage = this.initializeStorage();\n    }\n    /**\n     * Initialize storage based on configuration\n     */\n    initializeStorage() {\n        if (!isPlatformBrowser(this.platformId)) {\n            // Return a no-op storage for SSR\n            return {\n                getItem: () => null,\n                setItem: () => { },\n                removeItem: () => { },\n                clear: () => { }\n            };\n        }\n        switch (this.config.storage) {\n            case 'sessionStorage':\n                return sessionStorage;\n            case 'custom':\n                if (!this.config.customStorage) {\n                    this.logError('Custom storage specified but not provided');\n                    return localStorage;\n                }\n                return this.config.customStorage;\n            case 'localStorage':\n            default:\n                return localStorage;\n        }\n    }\n    /**\n     * Store a value securely\n     */\n    setItem(key, value) {\n        try {\n            // In production, consider encrypting sensitive values\n            this.storage.setItem(key, value);\n            this.logDebug(`Stored item with key: ${key}`);\n        }\n        catch (error) {\n            this.logError('Error storing item:', error);\n            throw new Error('Failed to store item');\n        }\n    }\n    /**\n     * Retrieve a value securely\n     */\n    getItem(key) {\n        try {\n            const value = this.storage.getItem(key);\n            this.logDebug(`Retrieved item with key: ${key}`, value ? 'Found' : 'Not found');\n            return value;\n        }\n        catch (error) {\n            this.logError('Error retrieving item:', error);\n            return null;\n        }\n    }\n    /**\n     * Remove a specific item\n     */\n    removeItem(key) {\n        try {\n            this.storage.removeItem(key);\n            this.logDebug(`Removed item with key: ${key}`);\n        }\n        catch (error) {\n            this.logError('Error removing item:', error);\n        }\n    }\n    /**\n     * Clear all OAuth2 related storage\n     */\n    clearAll() {\n        try {\n            Object.values(OAUTH2_STORAGE_KEYS).forEach(key => {\n                this.storage.removeItem(key);\n            });\n            this.logDebug('Cleared all OAuth2 storage');\n        }\n        catch (error) {\n            this.logError('Error clearing storage:', error);\n        }\n    }\n    /**\n     * Clear only token-related storage, preserve OAuth2 flow storage\n     */\n    clearTokens() {\n        try {\n            const tokenKeys = [\n                OAUTH2_STORAGE_KEYS.ACCESS_TOKEN,\n                OAUTH2_STORAGE_KEYS.REFRESH_TOKEN,\n                OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT,\n                OAUTH2_STORAGE_KEYS.TOKEN_TYPE,\n                OAUTH2_STORAGE_KEYS.SCOPE,\n                OAUTH2_STORAGE_KEYS.ID_TOKEN\n            ];\n            tokenKeys.forEach(key => {\n                this.storage.removeItem(key);\n            });\n            this.logDebug('Cleared token storage (OAuth2 flow storage preserved)');\n        }\n        catch (error) {\n            this.logError('Error clearing token storage:', error);\n        }\n    }\n    /**\n     * Clear temporary OAuth2 flow storage\n     */\n    clearTemporary() {\n        try {\n            this.storage.removeItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER);\n            this.storage.removeItem(OAUTH2_STORAGE_KEYS.STATE);\n            this.storage.removeItem(OAUTH2_STORAGE_KEYS.NONCE);\n            this.logDebug('Cleared temporary OAuth2 storage');\n        }\n        catch (error) {\n            this.logError('Error clearing temporary storage:', error);\n        }\n    }\n    /**\n     * Check if storage is available\n     */\n    isAvailable() {\n        return isPlatformBrowser(this.platformId);\n    }\n    /**\n     * Get all stored keys (for debugging)\n     */\n    getStoredKeys() {\n        if (!this.isAvailable()) {\n            return [];\n        }\n        try {\n            const keys = [];\n            for (let i = 0; i < this.storage.length; i++) {\n                const key = this.storage.key(i);\n                if (key && Object.values(OAUTH2_STORAGE_KEYS).includes(key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        }\n        catch (error) {\n            this.logError('Error getting stored keys:', error);\n            return [];\n        }\n    }\n    /**\n     * Debug logging\n     */\n    logDebug(message, ...args) {\n        if (this.logLevel === 'debug') {\n            console.log(`[OAuth2StorageService] ${message}`, ...args);\n        }\n    }\n    /**\n     * Info logging\n     */\n    logInfo(message, ...args) {\n        if (['debug', 'info'].includes(this.logLevel)) {\n            console.info(`[OAuth2StorageService] ${message}`, ...args);\n        }\n    }\n    /**\n     * Warning logging\n     */\n    logWarn(message, ...args) {\n        if (['debug', 'info', 'warn'].includes(this.logLevel)) {\n            console.warn(`[OAuth2StorageService] ${message}`, ...args);\n        }\n    }\n    /**\n     * Error logging\n     */\n    logError(message, error) {\n        if (this.logLevel !== 'none') {\n            console.error(`[OAuth2StorageService] ${message}`, error);\n        }\n    }\n    static { this.ɵfac = function OAuth2StorageService_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || OAuth2StorageService)(i0.ɵɵinject(OAUTH2_CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID)); }; }\n    static { this.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OAuth2StorageService, factory: OAuth2StorageService.ɵfac, providedIn: 'root' }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OAuth2StorageService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], () => [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [OAUTH2_CONFIG_TOKEN]\n            }] }, { type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }], null); })();","originalLength":21523,"removedExports":[],"renderedExports":["OAuth2StorageService"],"renderedLength":6325},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/services/oauth2.service.mjs":{"code":"/**\n * OAuth2 Service with PKCE Support\n * Handles OAuth2 authorization flow, token management, and user authentication\n */\nclass OAuth2Service {\n    constructor(config, platformId, http, router, storageService) {\n        this.config = config;\n        this.platformId = platformId;\n        this.http = http;\n        this.router = router;\n        this.storageService = storageService;\n        this._authState = signal({\n            isAuthenticated: false,\n            isLoading: false\n        });\n        this._authStateSubject = new BehaviorSubject({\n            isAuthenticated: false,\n            isLoading: false\n        });\n        this.authState$ = this._authStateSubject.asObservable();\n        this.authState = this._authState.asReadonly();\n        this.logLevel = config.logLevel || 'warn';\n        this.initializeAuthState();\n    }\n    /**\n     * Initialize authentication state from stored tokens\n     */\n    initializeAuthState() {\n        if (!isPlatformBrowser(this.platformId)) {\n            return;\n        }\n        try {\n            const tokenInfo = this.getStoredTokenInfo();\n            if (tokenInfo && this.isTokenValid(tokenInfo)) {\n                this.updateAuthState({\n                    isAuthenticated: true,\n                    isLoading: false,\n                    tokenInfo\n                });\n                this.logInfo('Authentication state initialized from stored tokens');\n            }\n            else if (tokenInfo && tokenInfo.refreshToken) {\n                // Access token is expired but refresh token exists\n                this.logInfo('Access token expired but refresh token available - preserving for refresh flow');\n                this.updateAuthState({\n                    isAuthenticated: false,\n                    isLoading: false,\n                    tokenInfo: undefined\n                });\n            }\n            else {\n                // No tokens or no refresh token available - clear everything\n                this.storageService.clearTokens();\n                this.logInfo('No valid stored tokens found');\n            }\n        }\n        catch (error) {\n            this.logError('Error initializing auth state:', error);\n            this.storageService.clearTokens();\n        }\n    }\n    /**\n     * Generate cryptographically secure PKCE challenge\n     */\n    async generatePKCEChallenge() {\n        const codeVerifier = this.generateSecureCodeVerifier();\n        const codeChallenge = await this.createCodeChallenge(codeVerifier);\n        return {\n            codeVerifier,\n            codeChallenge,\n            codeChallengeMethod: this.config.codeChallengeMethod || 'S256'\n        };\n    }\n    /**\n     * Generate cryptographically secure 6-digit code verifier\n     */\n    generateSecureCodeVerifier() {\n        if (!isPlatformBrowser(this.platformId)) {\n            throw new Error('Code verifier generation requires browser environment');\n        }\n        // Generate 6 cryptographically secure random digits\n        const array = new Uint8Array(6);\n        crypto.getRandomValues(array);\n        // Convert to 6-digit string (000000-999999)\n        const codeVerifier = Array.from(array)\n            .map(byte => (byte % 10).toString())\n            .join('');\n        this.logDebug('Generated secure 6-digit code verifier');\n        return codeVerifier;\n    }\n    /**\n     * Create SHA-256 hash and base64 encode for code challenge\n     */\n    async createCodeChallenge(codeVerifier) {\n        if (!isPlatformBrowser(this.platformId)) {\n            throw new Error('Code challenge creation requires browser environment');\n        }\n        try {\n            // Encode the code verifier as UTF-8\n            const encoder = new TextEncoder();\n            const data = encoder.encode(codeVerifier);\n            // Create SHA-256 hash\n            const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n            // Convert to base64url encoding\n            const hashArray = new Uint8Array(hashBuffer);\n            const base64String = btoa(String.fromCharCode(...hashArray))\n                .replace(/\\+/g, '-')\n                .replace(/\\//g, '_')\n                .replace(/=/g, '');\n            this.logDebug('Generated code challenge from verifier');\n            return base64String;\n        }\n        catch (error) {\n            this.logError('Error creating code challenge:', error);\n            throw new Error('Failed to create code challenge');\n        }\n    }\n    /**\n     * Generate cryptographically secure state parameter for CSRF protection\n     */\n    generateState() {\n        if (!isPlatformBrowser(this.platformId)) {\n            return 'fallback-state';\n        }\n        const array = new Uint8Array(32);\n        crypto.getRandomValues(array);\n        return btoa(String.fromCharCode(...array))\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=/g, '');\n    }\n    /**\n     * Generate nonce if not provided in config\n     */\n    generateNonce() {\n        if (this.config.nonce) {\n            return this.config.nonce;\n        }\n        if (!isPlatformBrowser(this.platformId)) {\n            return 'fallback-nonce';\n        }\n        const array = new Uint8Array(16);\n        crypto.getRandomValues(array);\n        return btoa(String.fromCharCode(...array))\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=/g, '');\n    }\n    /**\n     * Start OAuth2 PKCE authorization flow\n     */\n    async startAuthorization() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.logError('Authorization attempted in non-browser environment', 'SSR or server context detected');\n            this.updateAuthState({\n                isLoading: false,\n                error: 'Authentication not available in server environment'\n            });\n            return;\n        }\n        try {\n            this.updateAuthState({ isLoading: true, error: undefined });\n            // Generate PKCE challenge\n            const pkceChallenge = await this.generatePKCEChallenge();\n            // Generate state for CSRF protection\n            const state = this.generateState();\n            // Generate nonce\n            const nonce = this.generateNonce();\n            // Store code verifier, state, and nonce securely\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER, pkceChallenge.codeVerifier);\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.STATE, state);\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.NONCE, nonce);\n            // Build authorization request\n            const authRequest = {\n                client_id: this.config.clientId,\n                redirect_uri: this.config.redirectUri,\n                response_type: this.config.responseType || 'code',\n                nonce,\n                audience: this.config.audience,\n                scope: this.config.scope,\n                code_challenge_method: pkceChallenge.codeChallengeMethod,\n                code_challenge: pkceChallenge.codeChallenge,\n                state\n            };\n            // Build authorization URL\n            const authUrl = this.buildAuthorizationUrl(authRequest);\n            this.logInfo('Starting OAuth2 PKCE authorization flow');\n            this.logDebug('Authorization URL:', authUrl);\n            // Redirect to authorization server\n            window.location.href = authUrl;\n        }\n        catch (error) {\n            this.logError('Error starting authorization:', error);\n            this.updateAuthState({\n                isLoading: false,\n                error: 'Failed to start authorization flow'\n            });\n            throw error;\n        }\n    }\n    /**\n     * Build authorization URL with parameters\n     */\n    buildAuthorizationUrl(request) {\n        const params = new URLSearchParams();\n        Object.entries(request).forEach(([key, value]) => {\n            if (value !== undefined) {\n                params.append(key, value.toString());\n            }\n        });\n        return `${this.config.authorizationEndpoint}?${params.toString()}`;\n    }\n    /**\n     * Handle OAuth2 callback and extract tokens\n     */\n    async handleCallback() {\n        if (!isPlatformBrowser(this.platformId)) {\n            throw new Error('Callback handling requires browser environment');\n        }\n        try {\n            this.updateAuthState({ isLoading: true, error: undefined });\n            const currentUrl = window.location.href;\n            this.logInfo('Handling OAuth2 callback:', currentUrl);\n            // Check for error in callback\n            const error = this.extractErrorFromCallback();\n            if (error) {\n                throw new Error(`OAuth2 Error: ${error.error} - ${error.error_description || 'Unknown error'}`);\n            }\n            // Extract authorization code from query parameters or hash fragment\n            const authCode = this.extractAuthorizationCode();\n            this.logDebug('Extracted authorization code:', authCode ? 'Found' : 'Not found');\n            if (authCode) {\n                await this.exchangeCodeForTokens(authCode);\n                return;\n            }\n            // Extract tokens from URL fragment (implicit flow)\n            const tokens = this.extractTokensFromFragment();\n            this.logDebug('Extracted tokens from fragment:', tokens ? 'Found' : 'Not found');\n            if (tokens) {\n                await this.handleTokenResponse(tokens);\n                return;\n            }\n            throw new Error('No authorization code or tokens found in callback');\n        }\n        catch (error) {\n            this.logError('Error handling callback:', error);\n            this.updateAuthState({\n                isLoading: false,\n                error: error instanceof Error ? error.message : 'Callback handling failed'\n            });\n            this.storageService.clearAll();\n            throw error;\n        }\n    }\n    /**\n     * Extract error from callback URL\n     */\n    extractErrorFromCallback() {\n        const urlParams = new URLSearchParams(window.location.search);\n        const hashParams = new URLSearchParams(window.location.hash.substring(1));\n        const error = urlParams.get('error') || hashParams.get('error');\n        if (error) {\n            return {\n                error,\n                error_description: urlParams.get('error_description') || hashParams.get('error_description') || undefined,\n                error_uri: urlParams.get('error_uri') || hashParams.get('error_uri') || undefined,\n                state: urlParams.get('state') || hashParams.get('state') || undefined\n            };\n        }\n        return null;\n    }\n    /**\n     * Extract authorization code from query parameters\n     */\n    extractAuthorizationCode() {\n        // First check query parameters\n        const urlParams = new URLSearchParams(window.location.search);\n        let code = urlParams.get('code');\n        // If not found in query params, check hash fragment\n        if (!code && window.location.hash) {\n            const hashParams = new URLSearchParams(window.location.hash.substring(1));\n            code = hashParams.get('code');\n        }\n        if (code) {\n            this.logDebug('Authorization code extracted from callback');\n            return code;\n        }\n        return null;\n    }\n    /**\n     * Extract tokens from URL fragment\n     */\n    extractTokensFromFragment() {\n        const fragment = window.location.hash.substring(1);\n        if (!fragment) {\n            return null;\n        }\n        const params = new URLSearchParams(fragment);\n        const accessToken = params.get('access_token');\n        if (accessToken) {\n            this.logDebug('Tokens extracted from URL fragment');\n            return {\n                access_token: accessToken,\n                refresh_token: params.get('refresh_token') || undefined,\n                token_type: params.get('token_type') || 'Bearer',\n                expires_in: parseInt(params.get('expires_in') || '3600', 10),\n                scope: params.get('scope') || undefined,\n                id_token: params.get('id_token') || undefined\n            };\n        }\n        return null;\n    }\n    /**\n     * Exchange authorization code for tokens\n     */\n    async exchangeCodeForTokens(authCode) {\n        const codeVerifier = this.storageService.getItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER);\n        if (!codeVerifier) {\n            this.logError('Code verifier not found in storage');\n            throw new Error('Code verifier not found in storage');\n        }\n        const tokenRequest = {\n            grant_type: 'authorization_code',\n            redirect_uri: this.config.redirectUri,\n            client_id: this.config.clientId,\n            code: authCode,\n            code_verifier: codeVerifier\n        };\n        this.logInfo('Exchanging authorization code for tokens');\n        // Convert to URL-encoded form data as per OAuth 2.0 standard\n        const formData = new URLSearchParams();\n        Object.entries(tokenRequest).forEach(([key, value]) => {\n            if (value !== undefined) {\n                formData.append(key, value.toString());\n            }\n        });\n        try {\n            const tokenResponse = await this.http.post(this.config.tokenEndpoint, formData.toString(), {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            }).toPromise();\n            if (tokenResponse) {\n                await this.handleTokenResponse(tokenResponse);\n            }\n            else {\n                throw new Error('No token response received');\n            }\n        }\n        catch (error) {\n            this.logError('Token exchange failed:', error);\n            throw new Error('Failed to exchange authorization code for tokens');\n        }\n    }\n    /**\n     * Handle token response and store tokens securely\n     */\n    async handleTokenResponse(tokenResponse) {\n        try {\n            // Validate state parameter for CSRF protection\n            await this.validateState();\n            // Create token info\n            const tokenInfo = {\n                accessToken: tokenResponse.access_token,\n                refreshToken: tokenResponse.refresh_token,\n                tokenType: tokenResponse.token_type || 'Bearer',\n                expiresAt: Date.now() + (tokenResponse.expires_in * 1000),\n                scope: tokenResponse.scope,\n                idToken: tokenResponse.id_token\n            };\n            // Store tokens securely\n            this.storeTokenInfo(tokenInfo);\n            // Update authentication state\n            this.updateAuthState({\n                isAuthenticated: true,\n                isLoading: false,\n                tokenInfo,\n                error: undefined\n            });\n            // Clean up temporary storage\n            this.storageService.clearTemporary();\n            this.logInfo('Tokens stored successfully, user authenticated');\n        }\n        catch (error) {\n            this.logError('Error handling token response:', error);\n            throw error;\n        }\n    }\n    /**\n     * Validate state parameter for CSRF protection\n     */\n    async validateState() {\n        const urlParams = new URLSearchParams(window.location.search);\n        const hashParams = new URLSearchParams(window.location.hash.substring(1));\n        const receivedState = urlParams.get('state') || hashParams.get('state');\n        const storedState = this.storageService.getItem(OAUTH2_STORAGE_KEYS.STATE);\n        if (!receivedState || !storedState || receivedState !== storedState) {\n            throw new Error('Invalid state parameter - possible CSRF attack');\n        }\n        this.logDebug('State parameter validated successfully');\n    }\n    /**\n     * Get current access token (only if valid/not expired)\n     */\n    getAccessToken() {\n        const tokenInfo = this.getStoredTokenInfo();\n        if (tokenInfo && this.isTokenValid(tokenInfo)) {\n            return tokenInfo.accessToken;\n        }\n        return null;\n    }\n    /**\n     * Get raw access token (even if expired) - used for refresh flow\n     */\n    getRawAccessToken() {\n        const tokenInfo = this.getStoredTokenInfo();\n        return tokenInfo?.accessToken || null;\n    }\n    /**\n     * Get current refresh token\n     */\n    getRefreshToken() {\n        const tokenInfo = this.getStoredTokenInfo();\n        return tokenInfo?.refreshToken || null;\n    }\n    /**\n     * Check if user is authenticated\n     */\n    isAuthenticated() {\n        const tokenInfo = this.getStoredTokenInfo();\n        return tokenInfo ? this.isTokenValid(tokenInfo) : false;\n    }\n    /**\n     * Check if authentication is available in current environment\n     */\n    isAuthenticationAvailable() {\n        return isPlatformBrowser(this.platformId);\n    }\n    /**\n     * Fetch user information from OIDC userinfo endpoint\n     */\n    async getUserInfo() {\n        if (!this.config.userInfoEndpoint) {\n            throw new Error('UserInfo endpoint not configured');\n        }\n        const accessToken = this.getAccessToken();\n        if (!accessToken) {\n            throw new Error('No access token available');\n        }\n        this.logInfo('Fetching user info from OIDC userinfo endpoint');\n        try {\n            const userInfo = await this.http.get(this.config.userInfoEndpoint, {\n                headers: {\n                    'Authorization': `Bearer ${accessToken}`\n                }\n            }).toPromise();\n            if (userInfo) {\n                this.logDebug('User info retrieved successfully:', userInfo);\n                return userInfo;\n            }\n            else {\n                throw new Error('No user info response received');\n            }\n        }\n        catch (error) {\n            this.logError('Failed to fetch user info:', error);\n            throw new Error('Failed to fetch user information');\n        }\n    }\n    /**\n     * Check if token is valid (not expired)\n     */\n    isTokenValid(tokenInfo) {\n        const threshold = (this.config.refreshThreshold || 300) * 1000; // Convert to milliseconds\n        return Date.now() < (tokenInfo.expiresAt - threshold);\n    }\n    /**\n     * Refresh access token using refresh token\n     */\n    async refreshAccessToken() {\n        const refreshToken = this.getRefreshToken();\n        if (!refreshToken) {\n            throw new Error('No refresh token available');\n        }\n        this.logInfo('Refreshing access token');\n        const tokenRequest = {\n            grant_type: 'refresh_token',\n            refresh_token: refreshToken,\n            client_id: this.config.clientId\n        };\n        // Convert to URL-encoded form data as per OAuth 2.0 standard\n        const formData = new URLSearchParams();\n        Object.entries(tokenRequest).forEach(([key, value]) => {\n            if (value !== undefined) {\n                formData.append(key, value.toString());\n            }\n        });\n        try {\n            const tokenResponse = await this.http.post(this.config.tokenEndpoint, formData.toString(), {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            }).toPromise();\n            if (tokenResponse) {\n                const tokenInfo = {\n                    accessToken: tokenResponse.access_token,\n                    refreshToken: tokenResponse.refresh_token || refreshToken,\n                    tokenType: tokenResponse.token_type || 'Bearer',\n                    expiresAt: Date.now() + (tokenResponse.expires_in * 1000),\n                    scope: tokenResponse.scope,\n                    idToken: tokenResponse.id_token\n                };\n                this.storeTokenInfo(tokenInfo);\n                this.updateAuthState({\n                    isAuthenticated: true,\n                    isLoading: false,\n                    tokenInfo\n                });\n                this.logInfo('Access token refreshed successfully');\n                return tokenResponse.access_token;\n            }\n            else {\n                throw new Error('No token response received');\n            }\n        }\n        catch (error) {\n            this.logError('Token refresh failed:', error);\n            // Only logout if it's a 400/401 error indicating invalid refresh token\n            if (error instanceof Error && 'status' in error) {\n                const httpError = error;\n                if (httpError.status === 400 || httpError.status === 401) {\n                    this.logInfo('Refresh token is invalid, logging out');\n                    this.logout();\n                }\n            }\n            else {\n                this.logInfo('Network or server error during token refresh, will retry later');\n            }\n            throw new Error('Failed to refresh access token');\n        }\n    }\n    /**\n     * Logout user and clean up all stored data\n     */\n    async logout() {\n        try {\n            this.updateAuthState({ isLoading: true });\n            // Revoke tokens if supported\n            await this.revokeTokens();\n            // Clear all stored authentication data\n            this.storageService.clearAll();\n            // Update authentication state\n            this.updateAuthState({\n                isAuthenticated: false,\n                isLoading: false,\n                tokenInfo: undefined,\n                error: undefined\n            });\n            this.logInfo('User logged out successfully');\n        }\n        catch (error) {\n            this.logError('Error during logout:', error);\n            // Still clear local data even if revocation fails\n            this.storageService.clearAll();\n            this.updateAuthState({\n                isAuthenticated: false,\n                isLoading: false,\n                tokenInfo: undefined\n            });\n        }\n    }\n    /**\n     * Revoke tokens at authorization server\n     */\n    async revokeTokens() {\n        if (!this.config.revokeEndpoint) {\n            this.logInfo('Token revocation endpoint not configured');\n            return;\n        }\n        const accessToken = this.getAccessToken();\n        const refreshToken = this.getRefreshToken();\n        const revokePromises = [];\n        if (accessToken) {\n            const revokeRequest = {\n                token: accessToken,\n                token_type_hint: 'access_token',\n                client_id: this.config.clientId\n            };\n            const formData = new URLSearchParams();\n            Object.entries(revokeRequest).forEach(([key, value]) => {\n                if (value !== undefined) {\n                    formData.append(key, value.toString());\n                }\n            });\n            revokePromises.push(this.http.post(this.config.revokeEndpoint, formData.toString(), {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            }).toPromise());\n        }\n        if (refreshToken) {\n            const revokeRequest = {\n                token: refreshToken,\n                token_type_hint: 'refresh_token',\n                client_id: this.config.clientId\n            };\n            const formData = new URLSearchParams();\n            Object.entries(revokeRequest).forEach(([key, value]) => {\n                if (value !== undefined) {\n                    formData.append(key, value.toString());\n                }\n            });\n            revokePromises.push(this.http.post(this.config.revokeEndpoint, formData.toString(), {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            }).toPromise());\n        }\n        if (revokePromises.length > 0) {\n            try {\n                await Promise.all(revokePromises);\n                this.logInfo('Tokens revoked successfully');\n            }\n            catch (error) {\n                this.logError('Token revocation failed:', error);\n                // Don't throw error, continue with logout\n            }\n        }\n    }\n    /**\n     * Store token information securely\n     */\n    storeTokenInfo(tokenInfo) {\n        try {\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN, tokenInfo.accessToken);\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT, tokenInfo.expiresAt.toString());\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_TYPE, tokenInfo.tokenType);\n            if (tokenInfo.refreshToken) {\n                this.storageService.setItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN, tokenInfo.refreshToken);\n            }\n            if (tokenInfo.scope) {\n                this.storageService.setItem(OAUTH2_STORAGE_KEYS.SCOPE, tokenInfo.scope);\n            }\n            if (tokenInfo.idToken) {\n                this.storageService.setItem(OAUTH2_STORAGE_KEYS.ID_TOKEN, tokenInfo.idToken);\n            }\n            this.logDebug('Token information stored securely');\n        }\n        catch (error) {\n            this.logError('Error storing token information:', error);\n            throw new Error('Failed to store token information');\n        }\n    }\n    /**\n     * Retrieve stored token information\n     */\n    getStoredTokenInfo() {\n        if (!this.storageService.isAvailable()) {\n            return null;\n        }\n        try {\n            const accessToken = this.storageService.getItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN);\n            const expiresAtStr = this.storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT);\n            if (!accessToken || !expiresAtStr) {\n                return null;\n            }\n            return {\n                accessToken,\n                refreshToken: this.storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN) || undefined,\n                tokenType: this.storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_TYPE) || 'Bearer',\n                expiresAt: parseInt(expiresAtStr, 10),\n                scope: this.storageService.getItem(OAUTH2_STORAGE_KEYS.SCOPE) || undefined,\n                idToken: this.storageService.getItem(OAUTH2_STORAGE_KEYS.ID_TOKEN) || undefined\n            };\n        }\n        catch (error) {\n            this.logError('Error retrieving stored token information:', error);\n            return null;\n        }\n    }\n    /**\n     * Update authentication state\n     */\n    updateAuthState(newState) {\n        const currentState = this._authState();\n        const updatedState = { ...currentState, ...newState };\n        this._authState.set(updatedState);\n        this._authStateSubject.next(updatedState);\n    }\n    /**\n     * Debug logging\n     */\n    logDebug(message, ...args) {\n        if (this.logLevel === 'debug') {\n            console.log(`[OAuth2Service] ${message}`, ...args);\n        }\n    }\n    /**\n     * Info logging\n     */\n    logInfo(message, ...args) {\n        if (['debug', 'info'].includes(this.logLevel)) {\n            console.info(`[OAuth2Service] ${message}`, ...args);\n        }\n    }\n    /**\n     * Warning logging\n     */\n    logWarn(message, ...args) {\n        if (['debug', 'info', 'warn'].includes(this.logLevel)) {\n            console.warn(`[OAuth2Service] ${message}`, ...args);\n        }\n    }\n    /**\n     * Error logging\n     */\n    logError(message, error) {\n        if (this.logLevel !== 'none') {\n            console.error(`[OAuth2Service] ${message}`, error);\n        }\n    }\n    static { this.ɵfac = function OAuth2Service_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || OAuth2Service)(i0.ɵɵinject(OAUTH2_CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.Router), i0.ɵɵinject(OAuth2StorageService)); }; }\n    static { this.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OAuth2Service, factory: OAuth2Service.ɵfac, providedIn: 'root' }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OAuth2Service, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], () => [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [OAUTH2_CONFIG_TOKEN]\n            }] }, { type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }, { type: i1.HttpClient }, { type: i2.Router }, { type: OAuth2StorageService }], null); })();","originalLength":95718,"removedExports":[],"renderedExports":["OAuth2Service"],"renderedLength":28351},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/interceptors/oauth2.interceptor.mjs":{"code":"// Global state for token refresh\nlet isRefreshing = false;\nlet refreshTokenSubject = new BehaviorSubject(null);\n/**\n * OAuth2 HTTP Interceptor Function\n * Automatically adds Bearer tokens to requests and handles token refresh\n */\nconst oauth2InterceptorFn = (request, next) => {\n    const platformId = inject(PLATFORM_ID);\n    const config = inject(OAUTH2_CONFIG_TOKEN);\n    const storageService = inject(OAuth2StorageService);\n    const logLevel = config.logLevel || 'warn';\n    // Only intercept requests that should have OAuth2 tokens\n    if (!shouldInterceptRequest(request, config)) {\n        return next(request);\n    }\n    // Get access token directly from storage to avoid circular dependency\n    let accessToken = storageService.getItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN);\n    const hasValidToken = accessToken && isTokenValid(storageService);\n    logDebug(logLevel, 'Access token retrieved:', accessToken ? (hasValidToken ? 'Valid' : 'Expired') : 'Not found');\n    logDebug(logLevel, 'Request URL:', request.url);\n    // Always add token if available, even if expired (server will reject and we'll refresh)\n    if (accessToken) {\n        request = addTokenToRequest(request, accessToken);\n        logDebug(logLevel, 'Authorization header added to request');\n    }\n    else {\n        logDebug(logLevel, 'No access token available, proceeding without Authorization header');\n    }\n    return next(request).pipe(catchError((error) => {\n        // Handle 401 Unauthorized errors - attempt refresh if we have access token OR refresh token\n        if (error.status === 401) {\n            const refreshToken = storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN);\n            if (accessToken || refreshToken) {\n                logInfo(logLevel, '401 error detected, attempting token refresh');\n                logDebug(logLevel, 'Has access token:', !!accessToken, 'Has refresh token:', !!refreshToken);\n                return handle401Error(request, next, config, storageService, logLevel);\n            }\n            else {\n                logInfo(logLevel, '401 error but no tokens available for refresh');\n            }\n        }\n        return throwError(() => error);\n    }));\n};\n/**\n * Check if token is valid (not expired)\n */\nfunction isTokenValid(storageService) {\n    const expiresAtStr = storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT);\n    if (!expiresAtStr) {\n        return false;\n    }\n    const expiresAt = parseInt(expiresAtStr, 10);\n    return Date.now() < expiresAt;\n}\n/**\n * Check if request should be intercepted\n */\nfunction shouldInterceptRequest(request, config) {\n    // Exclude token refresh requests to avoid circular dependency\n    if (request.url === config.tokenEndpoint) {\n        return false;\n    }\n    // Exclude revoke requests\n    if (config.revokeEndpoint && request.url === config.revokeEndpoint) {\n        return false;\n    }\n    // You can customize this logic based on your needs\n    // For example, only intercept requests to specific domains or paths\n    return true;\n}\n/**\n * Add Bearer token to request headers\n */\nfunction addTokenToRequest(request, token) {\n    return request.clone({\n        setHeaders: {\n            Authorization: `Bearer ${token}`\n        }\n    });\n}\n/**\n * Handle 401 Unauthorized errors by attempting token refresh\n */\nfunction handle401Error(request, next, config, storageService, logLevel) {\n    if (!isRefreshing) {\n        isRefreshing = true;\n        refreshTokenSubject.next(null);\n        const refreshToken = storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN);\n        if (!refreshToken) {\n            isRefreshing = false;\n            logInfo(logLevel, 'No refresh token available');\n            return throwError(() => new Error('No refresh token available'));\n        }\n        // Create token refresh request directly using HttpRequest\n        const tokenRequestData = {\n            grant_type: 'refresh_token',\n            refresh_token: refreshToken,\n            client_id: config.clientId\n        };\n        // Convert to URL-encoded form data as per OAuth 2.0 standard\n        const formData = new URLSearchParams();\n        Object.entries(tokenRequestData).forEach(([key, value]) => {\n            if (value !== undefined) {\n                formData.append(key, value.toString());\n            }\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded'\n        });\n        const refreshRequest = new HttpRequest('POST', config.tokenEndpoint, formData.toString(), {\n            headers: headers\n        });\n        return next(refreshRequest).pipe(filter((event) => event instanceof HttpResponse), switchMap((event) => {\n            const tokenResponse = event.body;\n            isRefreshing = false;\n            if (tokenResponse?.access_token) {\n                // Store new tokens\n                storageService.setItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN, tokenResponse.access_token);\n                storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT, (Date.now() + (tokenResponse.expires_in * 1000)).toString());\n                if (tokenResponse.refresh_token) {\n                    storageService.setItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN, tokenResponse.refresh_token);\n                }\n                refreshTokenSubject.next(tokenResponse.access_token);\n                logInfo(logLevel, 'Token refreshed successfully, retrying original request');\n                // Retry the original request with new token\n                return next(addTokenToRequest(request, tokenResponse.access_token));\n            }\n            else {\n                throw new Error('No access token in refresh response');\n            }\n        }), catchError(error => {\n            isRefreshing = false;\n            refreshTokenSubject.next(null);\n            logError(logLevel, 'Token refresh failed:', error);\n            // Check if it's an authentication error (invalid refresh token)\n            if (error?.status === 400 || error?.status === 401) {\n                logInfo(logLevel, 'Refresh token is invalid, clearing tokens');\n                // Clear all OAuth2 tokens from storage\n                storageService.clearAll();\n                // Optionally redirect to login or emit an event\n                // This depends on your application's requirements\n            }\n            else {\n                logInfo(logLevel, 'Network/server error, not clearing tokens');\n            }\n            return throwError(() => error);\n        }));\n    }\n    else {\n        // Wait for refresh to complete, then retry request\n        return refreshTokenSubject.pipe(filter(token => token != null), take(1), switchMap(token => next(addTokenToRequest(request, token))));\n    }\n}\n/**\n * Debug logging\n */\nfunction logDebug(logLevel, message, ...args) {\n    if (logLevel === 'debug') {\n        console.log(`[OAuth2Interceptor] ${message}`, ...args);\n    }\n}\n/**\n * Info logging\n */\nfunction logInfo(logLevel, message, ...args) {\n    if (['debug', 'info'].includes(logLevel)) {\n        console.info(`[OAuth2Interceptor] ${message}`, ...args);\n    }\n}\n/**\n * Error logging\n */\nfunction logError(logLevel, message, error) {\n    if (logLevel !== 'none') {\n        console.error(`[OAuth2Interceptor] ${message}`, error);\n    }\n}","originalLength":28004,"removedExports":[],"renderedExports":["oauth2InterceptorFn"],"renderedLength":7288},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/components/oauth2-callback/oauth2-callback.component.mjs":{"code":"function OAuth2CallbackComponent_div_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵelement(1, \"div\", 6);\n    i0.ɵɵelementStart(2, \"h2\");\n    i0.ɵɵtext(3, \"Processing Authentication...\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"p\");\n    i0.ɵɵtext(5, \"Please wait while we complete your login.\");\n    i0.ɵɵelementEnd()();\n} }\nfunction OAuth2CallbackComponent_div_3_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7)(1, \"div\", 8);\n    i0.ɵɵtext(2, \"\\u2713\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"h2\");\n    i0.ɵɵtext(4, \"Authentication Successful!\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"p\");\n    i0.ɵɵtext(6, \"You will be redirected shortly...\");\n    i0.ɵɵelementEnd()();\n} }\nfunction OAuth2CallbackComponent_div_4_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 9)(1, \"div\", 10);\n    i0.ɵɵtext(2, \"\\u2717\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"h2\");\n    i0.ɵɵtext(4, \"Authentication Failed\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"p\", 11);\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"div\", 12)(8, \"button\", 13);\n    i0.ɵɵlistener(\"click\", function OAuth2CallbackComponent_div_4_Template_button_click_8_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.retryLogin()); });\n    i0.ɵɵtext(9, \" Try Again \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"button\", 14);\n    i0.ɵɵlistener(\"click\", function OAuth2CallbackComponent_div_4_Template_button_click_10_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.goHome()); });\n    i0.ɵɵtext(11, \" Go Home \");\n    i0.ɵɵelementEnd()()();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(ctx_r1.error);\n} }\n/**\n * OAuth2 Callback Component\n * Handles the OAuth2 authorization callback and processes the authorization code\n */\nclass OAuth2CallbackComponent {\n    constructor(oauth2Service, router, platformId) {\n        this.oauth2Service = oauth2Service;\n        this.router = router;\n        this.platformId = platformId;\n        this.isLoading = true;\n        this.error = null;\n        this.success = false;\n    }\n    async ngOnInit() {\n        // Only handle callback in browser environment\n        if (!isPlatformBrowser(this.platformId)) {\n            this.isLoading = false;\n            this.error = 'Browser environment required for OAuth2 callback';\n            return;\n        }\n        // Add a small delay to ensure the component is fully rendered on client side\n        setTimeout(async () => {\n            try {\n                console.log('Starting OAuth2 callback processing...');\n                console.log('Current URL:', window.location.href);\n                console.log('LocalStorage available:', typeof (Storage) !== \"undefined\");\n                // Handle the OAuth2 callback\n                await this.oauth2Service.handleCallback();\n                // Success\n                this.isLoading = false;\n                this.success = true;\n                // Redirect after a short delay\n                setTimeout(() => {\n                    // You can customize this redirect logic based on your needs\n                    // For example, redirect to a specific route or emit an event\n                    this.router.navigate(['/']);\n                }, 2000);\n            }\n            catch (error) {\n                console.error('OAuth2 callback error:', error);\n                this.isLoading = false;\n                this.error = error instanceof Error ? error.message : 'Authentication failed';\n            }\n        }, 100);\n    }\n    retryLogin() {\n        if (!this.oauth2Service.isAuthenticationAvailable()) {\n            this.error = 'Authentication not available in current environment';\n            return;\n        }\n        this.isLoading = true;\n        this.error = null;\n        this.success = false;\n        this.oauth2Service.startAuthorization().catch(error => {\n            console.error('Retry login error:', error);\n            this.isLoading = false;\n            this.error = 'Failed to start authentication';\n        });\n    }\n    goHome() {\n        this.router.navigate(['/']);\n    }\n    static { this.ɵfac = function OAuth2CallbackComponent_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || OAuth2CallbackComponent)(i0.ɵɵdirectiveInject(OAuth2Service), i0.ɵɵdirectiveInject(i2.Router), i0.ɵɵdirectiveInject(PLATFORM_ID)); }; }\n    static { this.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OAuth2CallbackComponent, selectors: [[\"lib-oauth2-callback\"]], decls: 5, vars: 3, consts: [[1, \"oauth2-callback-container\"], [1, \"oauth2-callback-content\"], [\"class\", \"loading-section\", 4, \"ngIf\"], [\"class\", \"success-section\", 4, \"ngIf\"], [\"class\", \"error-section\", 4, \"ngIf\"], [1, \"loading-section\"], [1, \"spinner\"], [1, \"success-section\"], [1, \"success-icon\"], [1, \"error-section\"], [1, \"error-icon\"], [1, \"error-message\"], [1, \"error-actions\"], [1, \"retry-button\", 3, \"click\"], [1, \"home-button\", 3, \"click\"]], template: function OAuth2CallbackComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n            i0.ɵɵtemplate(2, OAuth2CallbackComponent_div_2_Template, 6, 0, \"div\", 2)(3, OAuth2CallbackComponent_div_3_Template, 7, 0, \"div\", 3)(4, OAuth2CallbackComponent_div_4_Template, 12, 1, \"div\", 4);\n            i0.ɵɵelementEnd()();\n        } if (rf & 2) {\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"ngIf\", ctx.isLoading);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.success && !ctx.isLoading);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.error && !ctx.isLoading);\n        } }, dependencies: [CommonModule, i3.NgIf], styles: [\".oauth2-callback-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;min-height:100vh;background-color:#f5f5f5;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif}.oauth2-callback-content[_ngcontent-%COMP%]{background:#fff;border-radius:8px;padding:2rem;box-shadow:0 4px 6px #0000001a;text-align:center;max-width:400px;width:100%;margin:1rem}.loading-section[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%], .success-section[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%], .error-section[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{margin:1rem 0 .5rem;color:#333}.loading-section[_ngcontent-%COMP%]   p[_ngcontent-%COMP%], .success-section[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#666;margin-bottom:0}.spinner[_ngcontent-%COMP%]{border:3px solid #f3f3f3;border-top:3px solid #007bff;border-radius:50%;width:40px;height:40px;animation:_ngcontent-%COMP%_spin 1s linear infinite;margin:0 auto 1rem}@keyframes _ngcontent-%COMP%_spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.success-icon[_ngcontent-%COMP%]{width:60px;height:60px;border-radius:50%;background-color:#28a745;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2rem;font-weight:700;margin:0 auto 1rem}.error-icon[_ngcontent-%COMP%]{width:60px;height:60px;border-radius:50%;background-color:#dc3545;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2rem;font-weight:700;margin:0 auto 1rem}.error-message[_ngcontent-%COMP%]{color:#dc3545;margin:1rem 0;padding:.5rem;background-color:#f8d7da;border:1px solid #f5c6cb;border-radius:4px;font-size:.9rem}.error-actions[_ngcontent-%COMP%]{display:flex;gap:1rem;justify-content:center;margin-top:1.5rem}.retry-button[_ngcontent-%COMP%], .home-button[_ngcontent-%COMP%]{padding:.75rem 1.5rem;border:none;border-radius:4px;cursor:pointer;font-size:.9rem;font-weight:500;transition:background-color .2s}.retry-button[_ngcontent-%COMP%]{background-color:#007bff;color:#fff}.retry-button[_ngcontent-%COMP%]:hover{background-color:#0056b3}.home-button[_ngcontent-%COMP%]{background-color:#6c757d;color:#fff}.home-button[_ngcontent-%COMP%]:hover{background-color:#545b62}@media (max-width: 480px){.oauth2-callback-content[_ngcontent-%COMP%]{margin:.5rem;padding:1.5rem}.error-actions[_ngcontent-%COMP%]{flex-direction:column}.retry-button[_ngcontent-%COMP%], .home-button[_ngcontent-%COMP%]{width:100%}}\"] }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OAuth2CallbackComponent, [{\n        type: Component,\n        args: [{ selector: 'lib-oauth2-callback', standalone: true, imports: [CommonModule], template: `\r\n    <div class=\"oauth2-callback-container\">\r\n      <div class=\"oauth2-callback-content\">\r\n        <div *ngIf=\"isLoading\" class=\"loading-section\">\r\n          <div class=\"spinner\"></div>\r\n          <h2>Processing Authentication...</h2>\r\n          <p>Please wait while we complete your login.</p>\r\n        </div>\r\n\r\n        <div *ngIf=\"success && !isLoading\" class=\"success-section\">\r\n          <div class=\"success-icon\">✓</div>\r\n          <h2>Authentication Successful!</h2>\r\n          <p>You will be redirected shortly...</p>\r\n        </div>\r\n\r\n        <div *ngIf=\"error && !isLoading\" class=\"error-section\">\r\n          <div class=\"error-icon\">✗</div>\r\n          <h2>Authentication Failed</h2>\r\n          <p class=\"error-message\">{{ error }}</p>\r\n          <div class=\"error-actions\">\r\n            <button (click)=\"retryLogin()\" class=\"retry-button\">\r\n              Try Again\r\n            </button>\r\n            <button (click)=\"goHome()\" class=\"home-button\">\r\n              Go Home\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  `, styles: [\".oauth2-callback-container{display:flex;justify-content:center;align-items:center;min-height:100vh;background-color:#f5f5f5;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif}.oauth2-callback-content{background:#fff;border-radius:8px;padding:2rem;box-shadow:0 4px 6px #0000001a;text-align:center;max-width:400px;width:100%;margin:1rem}.loading-section h2,.success-section h2,.error-section h2{margin:1rem 0 .5rem;color:#333}.loading-section p,.success-section p{color:#666;margin-bottom:0}.spinner{border:3px solid #f3f3f3;border-top:3px solid #007bff;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;margin:0 auto 1rem}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.success-icon{width:60px;height:60px;border-radius:50%;background-color:#28a745;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2rem;font-weight:700;margin:0 auto 1rem}.error-icon{width:60px;height:60px;border-radius:50%;background-color:#dc3545;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2rem;font-weight:700;margin:0 auto 1rem}.error-message{color:#dc3545;margin:1rem 0;padding:.5rem;background-color:#f8d7da;border:1px solid #f5c6cb;border-radius:4px;font-size:.9rem}.error-actions{display:flex;gap:1rem;justify-content:center;margin-top:1.5rem}.retry-button,.home-button{padding:.75rem 1.5rem;border:none;border-radius:4px;cursor:pointer;font-size:.9rem;font-weight:500;transition:background-color .2s}.retry-button{background-color:#007bff;color:#fff}.retry-button:hover{background-color:#0056b3}.home-button{background-color:#6c757d;color:#fff}.home-button:hover{background-color:#545b62}@media (max-width: 480px){.oauth2-callback-content{margin:.5rem;padding:1.5rem}.error-actions{flex-direction:column}.retry-button,.home-button{width:100%}}\\n\"] }]\n    }], () => [{ type: OAuth2Service }, { type: i2.Router }, { type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }], null); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(OAuth2CallbackComponent, { className: \"OAuth2CallbackComponent\", filePath: \"lib/components/oauth2-callback/oauth2-callback.component.ts\", lineNumber: 185 }); })();","originalLength":25915,"removedExports":[],"renderedExports":["OAuth2CallbackComponent"],"renderedLength":11908},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/guards/oauth2-auth.guard.mjs":{"code":"/**\n * OAuth2 Authentication Guard Function\n * Protects routes by checking if user is authenticated\n */\nconst oauth2AuthGuard = (route, state) => {\n    const oauth2Service = inject(OAuth2Service);\n    const router = inject(Router);\n    // Check if authentication is available in current environment\n    if (!oauth2Service.isAuthenticationAvailable()) {\n        console.warn('[OAuth2AuthGuard] Authentication not available in current environment');\n        return false;\n    }\n    // Check current authentication state\n    return oauth2Service.authState$.pipe(take(1), map(authState => {\n        if (authState.isAuthenticated) {\n            return true;\n        }\n        // Check if we have stored tokens that might be valid\n        if (oauth2Service.isAuthenticated()) {\n            return true;\n        }\n        // User is not authenticated, redirect to login or start OAuth flow\n        console.log('[OAuth2AuthGuard] User not authenticated, starting OAuth2 flow');\n        // You can customize this behavior:\n        // Option 1: Start OAuth2 flow immediately\n        oauth2Service.startAuthorization().catch(error => {\n            console.error('[OAuth2AuthGuard] Failed to start OAuth2 flow:', error);\n        });\n        // Option 2: Redirect to a login page\n        // router.navigate(['/login'], { queryParams: { returnUrl: state.url } });\n        return false;\n    }));\n};\n/**\n * OAuth2 Authentication Guard Class (for backward compatibility)\n * @deprecated Use oauth2AuthGuard function instead\n */\nclass OAuth2AuthGuard {\n    constructor(oauth2Service, router) {\n        this.oauth2Service = oauth2Service;\n        this.router = router;\n    }\n    canActivate(route, state) {\n        // Check if authentication is available in current environment\n        if (!this.oauth2Service.isAuthenticationAvailable()) {\n            console.warn('[OAuth2AuthGuard] Authentication not available in current environment');\n            return false;\n        }\n        // Check current authentication state\n        return this.oauth2Service.authState$.pipe(take(1), map(authState => {\n            if (authState.isAuthenticated) {\n                return true;\n            }\n            // Check if we have stored tokens that might be valid\n            if (this.oauth2Service.isAuthenticated()) {\n                return true;\n            }\n            // User is not authenticated, redirect to login or start OAuth flow\n            console.log('[OAuth2AuthGuard] User not authenticated, starting OAuth2 flow');\n            this.oauth2Service.startAuthorization().catch(error => {\n                console.error('[OAuth2AuthGuard] Failed to start OAuth2 flow:', error);\n            });\n            return false;\n        }));\n    }\n}\n/**\n * OAuth2 Unauthenticated Guard Function\n * Protects routes that should only be accessible to unauthenticated users\n * (e.g., login page, registration page)\n */\nconst oauth2UnauthGuard = (route, state) => {\n    const oauth2Service = inject(OAuth2Service);\n    const router = inject(Router);\n    // Check if authentication is available in current environment\n    if (!oauth2Service.isAuthenticationAvailable()) {\n        return true; // Allow access if auth is not available\n    }\n    // Check current authentication state\n    return oauth2Service.authState$.pipe(take(1), map(authState => {\n        if (!authState.isAuthenticated && !oauth2Service.isAuthenticated()) {\n            return true; // User is not authenticated, allow access\n        }\n        // User is authenticated, redirect to protected area\n        console.log('[OAuth2UnauthGuard] User already authenticated, redirecting');\n        router.navigate(['/']); // Redirect to home or dashboard\n        return false;\n    }));\n};\nfunction oauth2RoleGuard(config) {\n    return (route, state) => {\n        const oauth2Service = inject(OAuth2Service);\n        const router = inject(Router);\n        // First check if user is authenticated\n        if (!oauth2Service.isAuthenticated()) {\n            console.log('[OAuth2RoleGuard] User not authenticated');\n            oauth2Service.startAuthorization().catch(error => {\n                console.error('[OAuth2RoleGuard] Failed to start OAuth2 flow:', error);\n            });\n            return false;\n        }\n        // If no roles or permissions specified, just check authentication\n        if (!config.roles?.length && !config.permissions?.length) {\n            return true;\n        }\n        // Get user info to check roles/permissions\n        return oauth2Service.getUserInfo().then(userInfo => {\n            const userRoles = userInfo.roles || [];\n            const userPermissions = userInfo.permissions || [];\n            let hasRequiredRoles = true;\n            let hasRequiredPermissions = true;\n            // Check roles\n            if (config.roles?.length) {\n                if (config.requireAll) {\n                    hasRequiredRoles = config.roles.every(role => userRoles.includes(role));\n                }\n                else {\n                    hasRequiredRoles = config.roles.some(role => userRoles.includes(role));\n                }\n            }\n            // Check permissions\n            if (config.permissions?.length) {\n                if (config.requireAll) {\n                    hasRequiredPermissions = config.permissions.every(permission => userPermissions.includes(permission));\n                }\n                else {\n                    hasRequiredPermissions = config.permissions.some(permission => userPermissions.includes(permission));\n                }\n            }\n            const hasAccess = hasRequiredRoles && hasRequiredPermissions;\n            if (!hasAccess) {\n                console.warn('[OAuth2RoleGuard] User does not have required roles/permissions');\n                router.navigate(['/unauthorized']); // Redirect to unauthorized page\n            }\n            return hasAccess;\n        }).catch(error => {\n            console.error('[OAuth2RoleGuard] Failed to get user info:', error);\n            return false;\n        });\n    };\n}","originalLength":22147,"removedExports":[],"renderedExports":["oauth2AuthGuard","OAuth2AuthGuard","oauth2UnauthGuard","oauth2RoleGuard"],"renderedLength":6030},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/lib/ng-oauth2-pkce.service.mjs":{"code":"/**\n * Provide OAuth2 configuration and services\n * Use this function in your app.config.ts or main.ts\n */\nfunction provideOAuth2(config) {\n    return makeEnvironmentProviders([\n        // Provide the OAuth2 configuration\n        { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\n        // Provide the OAuth2 services\n        OAuth2Service,\n        OAuth2StorageService,\n        // Provide HTTP client with OAuth2 interceptor\n        provideHttpClient(withInterceptors([oauth2InterceptorFn]))\n    ]);\n}\n/**\n * Provide OAuth2 configuration and services without HTTP interceptor\n * Use this if you want to manually configure the HTTP interceptor\n */\nfunction provideOAuth2WithoutInterceptor(config) {\n    return makeEnvironmentProviders([\n        // Provide the OAuth2 configuration\n        { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\n        // Provide the OAuth2 services\n        OAuth2Service,\n        OAuth2StorageService\n    ]);\n}\nclass NgOAuth2PkceModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgOAuth2PkceModule,\n            providers: [\n                { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\n                OAuth2Service,\n                OAuth2StorageService\n            ]\n        };\n    }\n    static { this.ɵfac = function NgOAuth2PkceModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || NgOAuth2PkceModule)(); }; }\n    static { this.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: NgOAuth2PkceModule }); }\n    static { this.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [CommonModule] }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgOAuth2PkceModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule],\n                exports: []\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgOAuth2PkceModule, { imports: [CommonModule] }); })();","originalLength":7560,"removedExports":[],"renderedExports":["provideOAuth2","provideOAuth2WithoutInterceptor","NgOAuth2PkceModule"],"renderedLength":1979},"E:/Witspry/SourceCode/witspry-auth-ng-client/dist/witspry-auth-ng-client/esm2022/public-api.mjs":{"code":"/*\n * Public API Surface of ng-oauth2-pkce\n */\n// Export models","originalLength":2327,"removedExports":[],"renderedExports":[],"renderedLength":63},"E:\\Witspry\\SourceCode\\witspry-auth-ng-client\\dist\\witspry-auth-ng-client\\esm2022\\witspry-auth-ng-client.mjs":{"code":"/**\n * Generated bundle index. Do not edit.\n */","originalLength":500,"removedExports":[],"renderedExports":[],"renderedLength":47}},"referencedFiles":[],"code":"import * as i0 from '@angular/core';\nimport { InjectionToken, PLATFORM_ID, Injectable, Inject, signal, inject, Component, makeEnvironmentProviders, NgModule } from '@angular/core';\nimport * as i3 from '@angular/common';\nimport { isPlatformBrowser, CommonModule } from '@angular/common';\nimport { BehaviorSubject, throwError } from 'rxjs';\nimport * as i1 from '@angular/common/http';\nimport { HttpHeaders, HttpRequest, HttpResponse, provideHttpClient, withInterceptors } from '@angular/common/http';\nimport * as i2 from '@angular/router';\nimport { Router } from '@angular/router';\nimport { catchError, filter, switchMap, take, map } from 'rxjs/operators';\n\n/**\n * OAuth2 Storage Keys Constants\n */\nconst OAUTH2_STORAGE_KEYS = {\n    CODE_VERIFIER: 'oauth2_code_verifier',\n    STATE: 'oauth2_state',\n    ACCESS_TOKEN: 'oauth2_access_token',\n    REFRESH_TOKEN: 'oauth2_refresh_token',\n    TOKEN_EXPIRES_AT: 'oauth2_token_expires_at',\n    TOKEN_TYPE: 'oauth2_token_type',\n    SCOPE: 'oauth2_scope',\n    ID_TOKEN: 'oauth2_id_token',\n    NONCE: 'oauth2_nonce'\n};\n\n/**\n * Injection token for OAuth2 configuration\n */\nconst OAUTH2_CONFIG_TOKEN = new InjectionToken('OAUTH2_CONFIG');\n\n/**\n * OAuth2 Storage Service\n * Handles secure storage and retrieval of OAuth2 tokens and data\n */\nclass OAuth2StorageService {\n    constructor(config, platformId) {\n        this.config = config;\n        this.platformId = platformId;\n        this.logLevel = config.logLevel || 'warn';\n        this.storage = this.initializeStorage();\n    }\n    /**\n     * Initialize storage based on configuration\n     */\n    initializeStorage() {\n        if (!isPlatformBrowser(this.platformId)) {\n            // Return a no-op storage for SSR\n            return {\n                getItem: () => null,\n                setItem: () => { },\n                removeItem: () => { },\n                clear: () => { }\n            };\n        }\n        switch (this.config.storage) {\n            case 'sessionStorage':\n                return sessionStorage;\n            case 'custom':\n                if (!this.config.customStorage) {\n                    this.logError('Custom storage specified but not provided');\n                    return localStorage;\n                }\n                return this.config.customStorage;\n            case 'localStorage':\n            default:\n                return localStorage;\n        }\n    }\n    /**\n     * Store a value securely\n     */\n    setItem(key, value) {\n        try {\n            // In production, consider encrypting sensitive values\n            this.storage.setItem(key, value);\n            this.logDebug(`Stored item with key: ${key}`);\n        }\n        catch (error) {\n            this.logError('Error storing item:', error);\n            throw new Error('Failed to store item');\n        }\n    }\n    /**\n     * Retrieve a value securely\n     */\n    getItem(key) {\n        try {\n            const value = this.storage.getItem(key);\n            this.logDebug(`Retrieved item with key: ${key}`, value ? 'Found' : 'Not found');\n            return value;\n        }\n        catch (error) {\n            this.logError('Error retrieving item:', error);\n            return null;\n        }\n    }\n    /**\n     * Remove a specific item\n     */\n    removeItem(key) {\n        try {\n            this.storage.removeItem(key);\n            this.logDebug(`Removed item with key: ${key}`);\n        }\n        catch (error) {\n            this.logError('Error removing item:', error);\n        }\n    }\n    /**\n     * Clear all OAuth2 related storage\n     */\n    clearAll() {\n        try {\n            Object.values(OAUTH2_STORAGE_KEYS).forEach(key => {\n                this.storage.removeItem(key);\n            });\n            this.logDebug('Cleared all OAuth2 storage');\n        }\n        catch (error) {\n            this.logError('Error clearing storage:', error);\n        }\n    }\n    /**\n     * Clear only token-related storage, preserve OAuth2 flow storage\n     */\n    clearTokens() {\n        try {\n            const tokenKeys = [\n                OAUTH2_STORAGE_KEYS.ACCESS_TOKEN,\n                OAUTH2_STORAGE_KEYS.REFRESH_TOKEN,\n                OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT,\n                OAUTH2_STORAGE_KEYS.TOKEN_TYPE,\n                OAUTH2_STORAGE_KEYS.SCOPE,\n                OAUTH2_STORAGE_KEYS.ID_TOKEN\n            ];\n            tokenKeys.forEach(key => {\n                this.storage.removeItem(key);\n            });\n            this.logDebug('Cleared token storage (OAuth2 flow storage preserved)');\n        }\n        catch (error) {\n            this.logError('Error clearing token storage:', error);\n        }\n    }\n    /**\n     * Clear temporary OAuth2 flow storage\n     */\n    clearTemporary() {\n        try {\n            this.storage.removeItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER);\n            this.storage.removeItem(OAUTH2_STORAGE_KEYS.STATE);\n            this.storage.removeItem(OAUTH2_STORAGE_KEYS.NONCE);\n            this.logDebug('Cleared temporary OAuth2 storage');\n        }\n        catch (error) {\n            this.logError('Error clearing temporary storage:', error);\n        }\n    }\n    /**\n     * Check if storage is available\n     */\n    isAvailable() {\n        return isPlatformBrowser(this.platformId);\n    }\n    /**\n     * Get all stored keys (for debugging)\n     */\n    getStoredKeys() {\n        if (!this.isAvailable()) {\n            return [];\n        }\n        try {\n            const keys = [];\n            for (let i = 0; i < this.storage.length; i++) {\n                const key = this.storage.key(i);\n                if (key && Object.values(OAUTH2_STORAGE_KEYS).includes(key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        }\n        catch (error) {\n            this.logError('Error getting stored keys:', error);\n            return [];\n        }\n    }\n    /**\n     * Debug logging\n     */\n    logDebug(message, ...args) {\n        if (this.logLevel === 'debug') {\n            console.log(`[OAuth2StorageService] ${message}`, ...args);\n        }\n    }\n    /**\n     * Info logging\n     */\n    logInfo(message, ...args) {\n        if (['debug', 'info'].includes(this.logLevel)) {\n            console.info(`[OAuth2StorageService] ${message}`, ...args);\n        }\n    }\n    /**\n     * Warning logging\n     */\n    logWarn(message, ...args) {\n        if (['debug', 'info', 'warn'].includes(this.logLevel)) {\n            console.warn(`[OAuth2StorageService] ${message}`, ...args);\n        }\n    }\n    /**\n     * Error logging\n     */\n    logError(message, error) {\n        if (this.logLevel !== 'none') {\n            console.error(`[OAuth2StorageService] ${message}`, error);\n        }\n    }\n    static { this.ɵfac = function OAuth2StorageService_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || OAuth2StorageService)(i0.ɵɵinject(OAUTH2_CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID)); }; }\n    static { this.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OAuth2StorageService, factory: OAuth2StorageService.ɵfac, providedIn: 'root' }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OAuth2StorageService, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], () => [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [OAUTH2_CONFIG_TOKEN]\n            }] }, { type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }], null); })();\n\n/**\n * OAuth2 Service with PKCE Support\n * Handles OAuth2 authorization flow, token management, and user authentication\n */\nclass OAuth2Service {\n    constructor(config, platformId, http, router, storageService) {\n        this.config = config;\n        this.platformId = platformId;\n        this.http = http;\n        this.router = router;\n        this.storageService = storageService;\n        this._authState = signal({\n            isAuthenticated: false,\n            isLoading: false\n        });\n        this._authStateSubject = new BehaviorSubject({\n            isAuthenticated: false,\n            isLoading: false\n        });\n        this.authState$ = this._authStateSubject.asObservable();\n        this.authState = this._authState.asReadonly();\n        this.logLevel = config.logLevel || 'warn';\n        this.initializeAuthState();\n    }\n    /**\n     * Initialize authentication state from stored tokens\n     */\n    initializeAuthState() {\n        if (!isPlatformBrowser(this.platformId)) {\n            return;\n        }\n        try {\n            const tokenInfo = this.getStoredTokenInfo();\n            if (tokenInfo && this.isTokenValid(tokenInfo)) {\n                this.updateAuthState({\n                    isAuthenticated: true,\n                    isLoading: false,\n                    tokenInfo\n                });\n                this.logInfo('Authentication state initialized from stored tokens');\n            }\n            else if (tokenInfo && tokenInfo.refreshToken) {\n                // Access token is expired but refresh token exists\n                this.logInfo('Access token expired but refresh token available - preserving for refresh flow');\n                this.updateAuthState({\n                    isAuthenticated: false,\n                    isLoading: false,\n                    tokenInfo: undefined\n                });\n            }\n            else {\n                // No tokens or no refresh token available - clear everything\n                this.storageService.clearTokens();\n                this.logInfo('No valid stored tokens found');\n            }\n        }\n        catch (error) {\n            this.logError('Error initializing auth state:', error);\n            this.storageService.clearTokens();\n        }\n    }\n    /**\n     * Generate cryptographically secure PKCE challenge\n     */\n    async generatePKCEChallenge() {\n        const codeVerifier = this.generateSecureCodeVerifier();\n        const codeChallenge = await this.createCodeChallenge(codeVerifier);\n        return {\n            codeVerifier,\n            codeChallenge,\n            codeChallengeMethod: this.config.codeChallengeMethod || 'S256'\n        };\n    }\n    /**\n     * Generate cryptographically secure 6-digit code verifier\n     */\n    generateSecureCodeVerifier() {\n        if (!isPlatformBrowser(this.platformId)) {\n            throw new Error('Code verifier generation requires browser environment');\n        }\n        // Generate 6 cryptographically secure random digits\n        const array = new Uint8Array(6);\n        crypto.getRandomValues(array);\n        // Convert to 6-digit string (000000-999999)\n        const codeVerifier = Array.from(array)\n            .map(byte => (byte % 10).toString())\n            .join('');\n        this.logDebug('Generated secure 6-digit code verifier');\n        return codeVerifier;\n    }\n    /**\n     * Create SHA-256 hash and base64 encode for code challenge\n     */\n    async createCodeChallenge(codeVerifier) {\n        if (!isPlatformBrowser(this.platformId)) {\n            throw new Error('Code challenge creation requires browser environment');\n        }\n        try {\n            // Encode the code verifier as UTF-8\n            const encoder = new TextEncoder();\n            const data = encoder.encode(codeVerifier);\n            // Create SHA-256 hash\n            const hashBuffer = await crypto.subtle.digest('SHA-256', data);\n            // Convert to base64url encoding\n            const hashArray = new Uint8Array(hashBuffer);\n            const base64String = btoa(String.fromCharCode(...hashArray))\n                .replace(/\\+/g, '-')\n                .replace(/\\//g, '_')\n                .replace(/=/g, '');\n            this.logDebug('Generated code challenge from verifier');\n            return base64String;\n        }\n        catch (error) {\n            this.logError('Error creating code challenge:', error);\n            throw new Error('Failed to create code challenge');\n        }\n    }\n    /**\n     * Generate cryptographically secure state parameter for CSRF protection\n     */\n    generateState() {\n        if (!isPlatformBrowser(this.platformId)) {\n            return 'fallback-state';\n        }\n        const array = new Uint8Array(32);\n        crypto.getRandomValues(array);\n        return btoa(String.fromCharCode(...array))\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=/g, '');\n    }\n    /**\n     * Generate nonce if not provided in config\n     */\n    generateNonce() {\n        if (this.config.nonce) {\n            return this.config.nonce;\n        }\n        if (!isPlatformBrowser(this.platformId)) {\n            return 'fallback-nonce';\n        }\n        const array = new Uint8Array(16);\n        crypto.getRandomValues(array);\n        return btoa(String.fromCharCode(...array))\n            .replace(/\\+/g, '-')\n            .replace(/\\//g, '_')\n            .replace(/=/g, '');\n    }\n    /**\n     * Start OAuth2 PKCE authorization flow\n     */\n    async startAuthorization() {\n        if (!isPlatformBrowser(this.platformId)) {\n            this.logError('Authorization attempted in non-browser environment', 'SSR or server context detected');\n            this.updateAuthState({\n                isLoading: false,\n                error: 'Authentication not available in server environment'\n            });\n            return;\n        }\n        try {\n            this.updateAuthState({ isLoading: true, error: undefined });\n            // Generate PKCE challenge\n            const pkceChallenge = await this.generatePKCEChallenge();\n            // Generate state for CSRF protection\n            const state = this.generateState();\n            // Generate nonce\n            const nonce = this.generateNonce();\n            // Store code verifier, state, and nonce securely\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER, pkceChallenge.codeVerifier);\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.STATE, state);\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.NONCE, nonce);\n            // Build authorization request\n            const authRequest = {\n                client_id: this.config.clientId,\n                redirect_uri: this.config.redirectUri,\n                response_type: this.config.responseType || 'code',\n                nonce,\n                audience: this.config.audience,\n                scope: this.config.scope,\n                code_challenge_method: pkceChallenge.codeChallengeMethod,\n                code_challenge: pkceChallenge.codeChallenge,\n                state\n            };\n            // Build authorization URL\n            const authUrl = this.buildAuthorizationUrl(authRequest);\n            this.logInfo('Starting OAuth2 PKCE authorization flow');\n            this.logDebug('Authorization URL:', authUrl);\n            // Redirect to authorization server\n            window.location.href = authUrl;\n        }\n        catch (error) {\n            this.logError('Error starting authorization:', error);\n            this.updateAuthState({\n                isLoading: false,\n                error: 'Failed to start authorization flow'\n            });\n            throw error;\n        }\n    }\n    /**\n     * Build authorization URL with parameters\n     */\n    buildAuthorizationUrl(request) {\n        const params = new URLSearchParams();\n        Object.entries(request).forEach(([key, value]) => {\n            if (value !== undefined) {\n                params.append(key, value.toString());\n            }\n        });\n        return `${this.config.authorizationEndpoint}?${params.toString()}`;\n    }\n    /**\n     * Handle OAuth2 callback and extract tokens\n     */\n    async handleCallback() {\n        if (!isPlatformBrowser(this.platformId)) {\n            throw new Error('Callback handling requires browser environment');\n        }\n        try {\n            this.updateAuthState({ isLoading: true, error: undefined });\n            const currentUrl = window.location.href;\n            this.logInfo('Handling OAuth2 callback:', currentUrl);\n            // Check for error in callback\n            const error = this.extractErrorFromCallback();\n            if (error) {\n                throw new Error(`OAuth2 Error: ${error.error} - ${error.error_description || 'Unknown error'}`);\n            }\n            // Extract authorization code from query parameters or hash fragment\n            const authCode = this.extractAuthorizationCode();\n            this.logDebug('Extracted authorization code:', authCode ? 'Found' : 'Not found');\n            if (authCode) {\n                await this.exchangeCodeForTokens(authCode);\n                return;\n            }\n            // Extract tokens from URL fragment (implicit flow)\n            const tokens = this.extractTokensFromFragment();\n            this.logDebug('Extracted tokens from fragment:', tokens ? 'Found' : 'Not found');\n            if (tokens) {\n                await this.handleTokenResponse(tokens);\n                return;\n            }\n            throw new Error('No authorization code or tokens found in callback');\n        }\n        catch (error) {\n            this.logError('Error handling callback:', error);\n            this.updateAuthState({\n                isLoading: false,\n                error: error instanceof Error ? error.message : 'Callback handling failed'\n            });\n            this.storageService.clearAll();\n            throw error;\n        }\n    }\n    /**\n     * Extract error from callback URL\n     */\n    extractErrorFromCallback() {\n        const urlParams = new URLSearchParams(window.location.search);\n        const hashParams = new URLSearchParams(window.location.hash.substring(1));\n        const error = urlParams.get('error') || hashParams.get('error');\n        if (error) {\n            return {\n                error,\n                error_description: urlParams.get('error_description') || hashParams.get('error_description') || undefined,\n                error_uri: urlParams.get('error_uri') || hashParams.get('error_uri') || undefined,\n                state: urlParams.get('state') || hashParams.get('state') || undefined\n            };\n        }\n        return null;\n    }\n    /**\n     * Extract authorization code from query parameters\n     */\n    extractAuthorizationCode() {\n        // First check query parameters\n        const urlParams = new URLSearchParams(window.location.search);\n        let code = urlParams.get('code');\n        // If not found in query params, check hash fragment\n        if (!code && window.location.hash) {\n            const hashParams = new URLSearchParams(window.location.hash.substring(1));\n            code = hashParams.get('code');\n        }\n        if (code) {\n            this.logDebug('Authorization code extracted from callback');\n            return code;\n        }\n        return null;\n    }\n    /**\n     * Extract tokens from URL fragment\n     */\n    extractTokensFromFragment() {\n        const fragment = window.location.hash.substring(1);\n        if (!fragment) {\n            return null;\n        }\n        const params = new URLSearchParams(fragment);\n        const accessToken = params.get('access_token');\n        if (accessToken) {\n            this.logDebug('Tokens extracted from URL fragment');\n            return {\n                access_token: accessToken,\n                refresh_token: params.get('refresh_token') || undefined,\n                token_type: params.get('token_type') || 'Bearer',\n                expires_in: parseInt(params.get('expires_in') || '3600', 10),\n                scope: params.get('scope') || undefined,\n                id_token: params.get('id_token') || undefined\n            };\n        }\n        return null;\n    }\n    /**\n     * Exchange authorization code for tokens\n     */\n    async exchangeCodeForTokens(authCode) {\n        const codeVerifier = this.storageService.getItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER);\n        if (!codeVerifier) {\n            this.logError('Code verifier not found in storage');\n            throw new Error('Code verifier not found in storage');\n        }\n        const tokenRequest = {\n            grant_type: 'authorization_code',\n            redirect_uri: this.config.redirectUri,\n            client_id: this.config.clientId,\n            code: authCode,\n            code_verifier: codeVerifier\n        };\n        this.logInfo('Exchanging authorization code for tokens');\n        // Convert to URL-encoded form data as per OAuth 2.0 standard\n        const formData = new URLSearchParams();\n        Object.entries(tokenRequest).forEach(([key, value]) => {\n            if (value !== undefined) {\n                formData.append(key, value.toString());\n            }\n        });\n        try {\n            const tokenResponse = await this.http.post(this.config.tokenEndpoint, formData.toString(), {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            }).toPromise();\n            if (tokenResponse) {\n                await this.handleTokenResponse(tokenResponse);\n            }\n            else {\n                throw new Error('No token response received');\n            }\n        }\n        catch (error) {\n            this.logError('Token exchange failed:', error);\n            throw new Error('Failed to exchange authorization code for tokens');\n        }\n    }\n    /**\n     * Handle token response and store tokens securely\n     */\n    async handleTokenResponse(tokenResponse) {\n        try {\n            // Validate state parameter for CSRF protection\n            await this.validateState();\n            // Create token info\n            const tokenInfo = {\n                accessToken: tokenResponse.access_token,\n                refreshToken: tokenResponse.refresh_token,\n                tokenType: tokenResponse.token_type || 'Bearer',\n                expiresAt: Date.now() + (tokenResponse.expires_in * 1000),\n                scope: tokenResponse.scope,\n                idToken: tokenResponse.id_token\n            };\n            // Store tokens securely\n            this.storeTokenInfo(tokenInfo);\n            // Update authentication state\n            this.updateAuthState({\n                isAuthenticated: true,\n                isLoading: false,\n                tokenInfo,\n                error: undefined\n            });\n            // Clean up temporary storage\n            this.storageService.clearTemporary();\n            this.logInfo('Tokens stored successfully, user authenticated');\n        }\n        catch (error) {\n            this.logError('Error handling token response:', error);\n            throw error;\n        }\n    }\n    /**\n     * Validate state parameter for CSRF protection\n     */\n    async validateState() {\n        const urlParams = new URLSearchParams(window.location.search);\n        const hashParams = new URLSearchParams(window.location.hash.substring(1));\n        const receivedState = urlParams.get('state') || hashParams.get('state');\n        const storedState = this.storageService.getItem(OAUTH2_STORAGE_KEYS.STATE);\n        if (!receivedState || !storedState || receivedState !== storedState) {\n            throw new Error('Invalid state parameter - possible CSRF attack');\n        }\n        this.logDebug('State parameter validated successfully');\n    }\n    /**\n     * Get current access token (only if valid/not expired)\n     */\n    getAccessToken() {\n        const tokenInfo = this.getStoredTokenInfo();\n        if (tokenInfo && this.isTokenValid(tokenInfo)) {\n            return tokenInfo.accessToken;\n        }\n        return null;\n    }\n    /**\n     * Get raw access token (even if expired) - used for refresh flow\n     */\n    getRawAccessToken() {\n        const tokenInfo = this.getStoredTokenInfo();\n        return tokenInfo?.accessToken || null;\n    }\n    /**\n     * Get current refresh token\n     */\n    getRefreshToken() {\n        const tokenInfo = this.getStoredTokenInfo();\n        return tokenInfo?.refreshToken || null;\n    }\n    /**\n     * Check if user is authenticated\n     */\n    isAuthenticated() {\n        const tokenInfo = this.getStoredTokenInfo();\n        return tokenInfo ? this.isTokenValid(tokenInfo) : false;\n    }\n    /**\n     * Check if authentication is available in current environment\n     */\n    isAuthenticationAvailable() {\n        return isPlatformBrowser(this.platformId);\n    }\n    /**\n     * Fetch user information from OIDC userinfo endpoint\n     */\n    async getUserInfo() {\n        if (!this.config.userInfoEndpoint) {\n            throw new Error('UserInfo endpoint not configured');\n        }\n        const accessToken = this.getAccessToken();\n        if (!accessToken) {\n            throw new Error('No access token available');\n        }\n        this.logInfo('Fetching user info from OIDC userinfo endpoint');\n        try {\n            const userInfo = await this.http.get(this.config.userInfoEndpoint, {\n                headers: {\n                    'Authorization': `Bearer ${accessToken}`\n                }\n            }).toPromise();\n            if (userInfo) {\n                this.logDebug('User info retrieved successfully:', userInfo);\n                return userInfo;\n            }\n            else {\n                throw new Error('No user info response received');\n            }\n        }\n        catch (error) {\n            this.logError('Failed to fetch user info:', error);\n            throw new Error('Failed to fetch user information');\n        }\n    }\n    /**\n     * Check if token is valid (not expired)\n     */\n    isTokenValid(tokenInfo) {\n        const threshold = (this.config.refreshThreshold || 300) * 1000; // Convert to milliseconds\n        return Date.now() < (tokenInfo.expiresAt - threshold);\n    }\n    /**\n     * Refresh access token using refresh token\n     */\n    async refreshAccessToken() {\n        const refreshToken = this.getRefreshToken();\n        if (!refreshToken) {\n            throw new Error('No refresh token available');\n        }\n        this.logInfo('Refreshing access token');\n        const tokenRequest = {\n            grant_type: 'refresh_token',\n            refresh_token: refreshToken,\n            client_id: this.config.clientId\n        };\n        // Convert to URL-encoded form data as per OAuth 2.0 standard\n        const formData = new URLSearchParams();\n        Object.entries(tokenRequest).forEach(([key, value]) => {\n            if (value !== undefined) {\n                formData.append(key, value.toString());\n            }\n        });\n        try {\n            const tokenResponse = await this.http.post(this.config.tokenEndpoint, formData.toString(), {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            }).toPromise();\n            if (tokenResponse) {\n                const tokenInfo = {\n                    accessToken: tokenResponse.access_token,\n                    refreshToken: tokenResponse.refresh_token || refreshToken,\n                    tokenType: tokenResponse.token_type || 'Bearer',\n                    expiresAt: Date.now() + (tokenResponse.expires_in * 1000),\n                    scope: tokenResponse.scope,\n                    idToken: tokenResponse.id_token\n                };\n                this.storeTokenInfo(tokenInfo);\n                this.updateAuthState({\n                    isAuthenticated: true,\n                    isLoading: false,\n                    tokenInfo\n                });\n                this.logInfo('Access token refreshed successfully');\n                return tokenResponse.access_token;\n            }\n            else {\n                throw new Error('No token response received');\n            }\n        }\n        catch (error) {\n            this.logError('Token refresh failed:', error);\n            // Only logout if it's a 400/401 error indicating invalid refresh token\n            if (error instanceof Error && 'status' in error) {\n                const httpError = error;\n                if (httpError.status === 400 || httpError.status === 401) {\n                    this.logInfo('Refresh token is invalid, logging out');\n                    this.logout();\n                }\n            }\n            else {\n                this.logInfo('Network or server error during token refresh, will retry later');\n            }\n            throw new Error('Failed to refresh access token');\n        }\n    }\n    /**\n     * Logout user and clean up all stored data\n     */\n    async logout() {\n        try {\n            this.updateAuthState({ isLoading: true });\n            // Revoke tokens if supported\n            await this.revokeTokens();\n            // Clear all stored authentication data\n            this.storageService.clearAll();\n            // Update authentication state\n            this.updateAuthState({\n                isAuthenticated: false,\n                isLoading: false,\n                tokenInfo: undefined,\n                error: undefined\n            });\n            this.logInfo('User logged out successfully');\n        }\n        catch (error) {\n            this.logError('Error during logout:', error);\n            // Still clear local data even if revocation fails\n            this.storageService.clearAll();\n            this.updateAuthState({\n                isAuthenticated: false,\n                isLoading: false,\n                tokenInfo: undefined\n            });\n        }\n    }\n    /**\n     * Revoke tokens at authorization server\n     */\n    async revokeTokens() {\n        if (!this.config.revokeEndpoint) {\n            this.logInfo('Token revocation endpoint not configured');\n            return;\n        }\n        const accessToken = this.getAccessToken();\n        const refreshToken = this.getRefreshToken();\n        const revokePromises = [];\n        if (accessToken) {\n            const revokeRequest = {\n                token: accessToken,\n                token_type_hint: 'access_token',\n                client_id: this.config.clientId\n            };\n            const formData = new URLSearchParams();\n            Object.entries(revokeRequest).forEach(([key, value]) => {\n                if (value !== undefined) {\n                    formData.append(key, value.toString());\n                }\n            });\n            revokePromises.push(this.http.post(this.config.revokeEndpoint, formData.toString(), {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            }).toPromise());\n        }\n        if (refreshToken) {\n            const revokeRequest = {\n                token: refreshToken,\n                token_type_hint: 'refresh_token',\n                client_id: this.config.clientId\n            };\n            const formData = new URLSearchParams();\n            Object.entries(revokeRequest).forEach(([key, value]) => {\n                if (value !== undefined) {\n                    formData.append(key, value.toString());\n                }\n            });\n            revokePromises.push(this.http.post(this.config.revokeEndpoint, formData.toString(), {\n                headers: {\n                    'Content-Type': 'application/x-www-form-urlencoded'\n                }\n            }).toPromise());\n        }\n        if (revokePromises.length > 0) {\n            try {\n                await Promise.all(revokePromises);\n                this.logInfo('Tokens revoked successfully');\n            }\n            catch (error) {\n                this.logError('Token revocation failed:', error);\n                // Don't throw error, continue with logout\n            }\n        }\n    }\n    /**\n     * Store token information securely\n     */\n    storeTokenInfo(tokenInfo) {\n        try {\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN, tokenInfo.accessToken);\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT, tokenInfo.expiresAt.toString());\n            this.storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_TYPE, tokenInfo.tokenType);\n            if (tokenInfo.refreshToken) {\n                this.storageService.setItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN, tokenInfo.refreshToken);\n            }\n            if (tokenInfo.scope) {\n                this.storageService.setItem(OAUTH2_STORAGE_KEYS.SCOPE, tokenInfo.scope);\n            }\n            if (tokenInfo.idToken) {\n                this.storageService.setItem(OAUTH2_STORAGE_KEYS.ID_TOKEN, tokenInfo.idToken);\n            }\n            this.logDebug('Token information stored securely');\n        }\n        catch (error) {\n            this.logError('Error storing token information:', error);\n            throw new Error('Failed to store token information');\n        }\n    }\n    /**\n     * Retrieve stored token information\n     */\n    getStoredTokenInfo() {\n        if (!this.storageService.isAvailable()) {\n            return null;\n        }\n        try {\n            const accessToken = this.storageService.getItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN);\n            const expiresAtStr = this.storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT);\n            if (!accessToken || !expiresAtStr) {\n                return null;\n            }\n            return {\n                accessToken,\n                refreshToken: this.storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN) || undefined,\n                tokenType: this.storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_TYPE) || 'Bearer',\n                expiresAt: parseInt(expiresAtStr, 10),\n                scope: this.storageService.getItem(OAUTH2_STORAGE_KEYS.SCOPE) || undefined,\n                idToken: this.storageService.getItem(OAUTH2_STORAGE_KEYS.ID_TOKEN) || undefined\n            };\n        }\n        catch (error) {\n            this.logError('Error retrieving stored token information:', error);\n            return null;\n        }\n    }\n    /**\n     * Update authentication state\n     */\n    updateAuthState(newState) {\n        const currentState = this._authState();\n        const updatedState = { ...currentState, ...newState };\n        this._authState.set(updatedState);\n        this._authStateSubject.next(updatedState);\n    }\n    /**\n     * Debug logging\n     */\n    logDebug(message, ...args) {\n        if (this.logLevel === 'debug') {\n            console.log(`[OAuth2Service] ${message}`, ...args);\n        }\n    }\n    /**\n     * Info logging\n     */\n    logInfo(message, ...args) {\n        if (['debug', 'info'].includes(this.logLevel)) {\n            console.info(`[OAuth2Service] ${message}`, ...args);\n        }\n    }\n    /**\n     * Warning logging\n     */\n    logWarn(message, ...args) {\n        if (['debug', 'info', 'warn'].includes(this.logLevel)) {\n            console.warn(`[OAuth2Service] ${message}`, ...args);\n        }\n    }\n    /**\n     * Error logging\n     */\n    logError(message, error) {\n        if (this.logLevel !== 'none') {\n            console.error(`[OAuth2Service] ${message}`, error);\n        }\n    }\n    static { this.ɵfac = function OAuth2Service_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || OAuth2Service)(i0.ɵɵinject(OAUTH2_CONFIG_TOKEN), i0.ɵɵinject(PLATFORM_ID), i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.Router), i0.ɵɵinject(OAuth2StorageService)); }; }\n    static { this.ɵprov = /*@__PURE__*/ i0.ɵɵdefineInjectable({ token: OAuth2Service, factory: OAuth2Service.ɵfac, providedIn: 'root' }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OAuth2Service, [{\n        type: Injectable,\n        args: [{\n                providedIn: 'root'\n            }]\n    }], () => [{ type: undefined, decorators: [{\n                type: Inject,\n                args: [OAUTH2_CONFIG_TOKEN]\n            }] }, { type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }, { type: i1.HttpClient }, { type: i2.Router }, { type: OAuth2StorageService }], null); })();\n\n// Global state for token refresh\nlet isRefreshing = false;\nlet refreshTokenSubject = new BehaviorSubject(null);\n/**\n * OAuth2 HTTP Interceptor Function\n * Automatically adds Bearer tokens to requests and handles token refresh\n */\nconst oauth2InterceptorFn = (request, next) => {\n    const platformId = inject(PLATFORM_ID);\n    const config = inject(OAUTH2_CONFIG_TOKEN);\n    const storageService = inject(OAuth2StorageService);\n    const logLevel = config.logLevel || 'warn';\n    // Only intercept requests that should have OAuth2 tokens\n    if (!shouldInterceptRequest(request, config)) {\n        return next(request);\n    }\n    // Get access token directly from storage to avoid circular dependency\n    let accessToken = storageService.getItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN);\n    const hasValidToken = accessToken && isTokenValid(storageService);\n    logDebug(logLevel, 'Access token retrieved:', accessToken ? (hasValidToken ? 'Valid' : 'Expired') : 'Not found');\n    logDebug(logLevel, 'Request URL:', request.url);\n    // Always add token if available, even if expired (server will reject and we'll refresh)\n    if (accessToken) {\n        request = addTokenToRequest(request, accessToken);\n        logDebug(logLevel, 'Authorization header added to request');\n    }\n    else {\n        logDebug(logLevel, 'No access token available, proceeding without Authorization header');\n    }\n    return next(request).pipe(catchError((error) => {\n        // Handle 401 Unauthorized errors - attempt refresh if we have access token OR refresh token\n        if (error.status === 401) {\n            const refreshToken = storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN);\n            if (accessToken || refreshToken) {\n                logInfo(logLevel, '401 error detected, attempting token refresh');\n                logDebug(logLevel, 'Has access token:', !!accessToken, 'Has refresh token:', !!refreshToken);\n                return handle401Error(request, next, config, storageService, logLevel);\n            }\n            else {\n                logInfo(logLevel, '401 error but no tokens available for refresh');\n            }\n        }\n        return throwError(() => error);\n    }));\n};\n/**\n * Check if token is valid (not expired)\n */\nfunction isTokenValid(storageService) {\n    const expiresAtStr = storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT);\n    if (!expiresAtStr) {\n        return false;\n    }\n    const expiresAt = parseInt(expiresAtStr, 10);\n    return Date.now() < expiresAt;\n}\n/**\n * Check if request should be intercepted\n */\nfunction shouldInterceptRequest(request, config) {\n    // Exclude token refresh requests to avoid circular dependency\n    if (request.url === config.tokenEndpoint) {\n        return false;\n    }\n    // Exclude revoke requests\n    if (config.revokeEndpoint && request.url === config.revokeEndpoint) {\n        return false;\n    }\n    // You can customize this logic based on your needs\n    // For example, only intercept requests to specific domains or paths\n    return true;\n}\n/**\n * Add Bearer token to request headers\n */\nfunction addTokenToRequest(request, token) {\n    return request.clone({\n        setHeaders: {\n            Authorization: `Bearer ${token}`\n        }\n    });\n}\n/**\n * Handle 401 Unauthorized errors by attempting token refresh\n */\nfunction handle401Error(request, next, config, storageService, logLevel) {\n    if (!isRefreshing) {\n        isRefreshing = true;\n        refreshTokenSubject.next(null);\n        const refreshToken = storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN);\n        if (!refreshToken) {\n            isRefreshing = false;\n            logInfo(logLevel, 'No refresh token available');\n            return throwError(() => new Error('No refresh token available'));\n        }\n        // Create token refresh request directly using HttpRequest\n        const tokenRequestData = {\n            grant_type: 'refresh_token',\n            refresh_token: refreshToken,\n            client_id: config.clientId\n        };\n        // Convert to URL-encoded form data as per OAuth 2.0 standard\n        const formData = new URLSearchParams();\n        Object.entries(tokenRequestData).forEach(([key, value]) => {\n            if (value !== undefined) {\n                formData.append(key, value.toString());\n            }\n        });\n        const headers = new HttpHeaders({\n            'Content-Type': 'application/x-www-form-urlencoded'\n        });\n        const refreshRequest = new HttpRequest('POST', config.tokenEndpoint, formData.toString(), {\n            headers: headers\n        });\n        return next(refreshRequest).pipe(filter((event) => event instanceof HttpResponse), switchMap((event) => {\n            const tokenResponse = event.body;\n            isRefreshing = false;\n            if (tokenResponse?.access_token) {\n                // Store new tokens\n                storageService.setItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN, tokenResponse.access_token);\n                storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT, (Date.now() + (tokenResponse.expires_in * 1000)).toString());\n                if (tokenResponse.refresh_token) {\n                    storageService.setItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN, tokenResponse.refresh_token);\n                }\n                refreshTokenSubject.next(tokenResponse.access_token);\n                logInfo(logLevel, 'Token refreshed successfully, retrying original request');\n                // Retry the original request with new token\n                return next(addTokenToRequest(request, tokenResponse.access_token));\n            }\n            else {\n                throw new Error('No access token in refresh response');\n            }\n        }), catchError(error => {\n            isRefreshing = false;\n            refreshTokenSubject.next(null);\n            logError(logLevel, 'Token refresh failed:', error);\n            // Check if it's an authentication error (invalid refresh token)\n            if (error?.status === 400 || error?.status === 401) {\n                logInfo(logLevel, 'Refresh token is invalid, clearing tokens');\n                // Clear all OAuth2 tokens from storage\n                storageService.clearAll();\n                // Optionally redirect to login or emit an event\n                // This depends on your application's requirements\n            }\n            else {\n                logInfo(logLevel, 'Network/server error, not clearing tokens');\n            }\n            return throwError(() => error);\n        }));\n    }\n    else {\n        // Wait for refresh to complete, then retry request\n        return refreshTokenSubject.pipe(filter(token => token != null), take(1), switchMap(token => next(addTokenToRequest(request, token))));\n    }\n}\n/**\n * Debug logging\n */\nfunction logDebug(logLevel, message, ...args) {\n    if (logLevel === 'debug') {\n        console.log(`[OAuth2Interceptor] ${message}`, ...args);\n    }\n}\n/**\n * Info logging\n */\nfunction logInfo(logLevel, message, ...args) {\n    if (['debug', 'info'].includes(logLevel)) {\n        console.info(`[OAuth2Interceptor] ${message}`, ...args);\n    }\n}\n/**\n * Error logging\n */\nfunction logError(logLevel, message, error) {\n    if (logLevel !== 'none') {\n        console.error(`[OAuth2Interceptor] ${message}`, error);\n    }\n}\n\nfunction OAuth2CallbackComponent_div_2_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 5);\n    i0.ɵɵelement(1, \"div\", 6);\n    i0.ɵɵelementStart(2, \"h2\");\n    i0.ɵɵtext(3, \"Processing Authentication...\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(4, \"p\");\n    i0.ɵɵtext(5, \"Please wait while we complete your login.\");\n    i0.ɵɵelementEnd()();\n} }\nfunction OAuth2CallbackComponent_div_3_Template(rf, ctx) { if (rf & 1) {\n    i0.ɵɵelementStart(0, \"div\", 7)(1, \"div\", 8);\n    i0.ɵɵtext(2, \"\\u2713\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"h2\");\n    i0.ɵɵtext(4, \"Authentication Successful!\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"p\");\n    i0.ɵɵtext(6, \"You will be redirected shortly...\");\n    i0.ɵɵelementEnd()();\n} }\nfunction OAuth2CallbackComponent_div_4_Template(rf, ctx) { if (rf & 1) {\n    const _r1 = i0.ɵɵgetCurrentView();\n    i0.ɵɵelementStart(0, \"div\", 9)(1, \"div\", 10);\n    i0.ɵɵtext(2, \"\\u2717\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(3, \"h2\");\n    i0.ɵɵtext(4, \"Authentication Failed\");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(5, \"p\", 11);\n    i0.ɵɵtext(6);\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(7, \"div\", 12)(8, \"button\", 13);\n    i0.ɵɵlistener(\"click\", function OAuth2CallbackComponent_div_4_Template_button_click_8_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.retryLogin()); });\n    i0.ɵɵtext(9, \" Try Again \");\n    i0.ɵɵelementEnd();\n    i0.ɵɵelementStart(10, \"button\", 14);\n    i0.ɵɵlistener(\"click\", function OAuth2CallbackComponent_div_4_Template_button_click_10_listener() { i0.ɵɵrestoreView(_r1); const ctx_r1 = i0.ɵɵnextContext(); return i0.ɵɵresetView(ctx_r1.goHome()); });\n    i0.ɵɵtext(11, \" Go Home \");\n    i0.ɵɵelementEnd()()();\n} if (rf & 2) {\n    const ctx_r1 = i0.ɵɵnextContext();\n    i0.ɵɵadvance(6);\n    i0.ɵɵtextInterpolate(ctx_r1.error);\n} }\n/**\n * OAuth2 Callback Component\n * Handles the OAuth2 authorization callback and processes the authorization code\n */\nclass OAuth2CallbackComponent {\n    constructor(oauth2Service, router, platformId) {\n        this.oauth2Service = oauth2Service;\n        this.router = router;\n        this.platformId = platformId;\n        this.isLoading = true;\n        this.error = null;\n        this.success = false;\n    }\n    async ngOnInit() {\n        // Only handle callback in browser environment\n        if (!isPlatformBrowser(this.platformId)) {\n            this.isLoading = false;\n            this.error = 'Browser environment required for OAuth2 callback';\n            return;\n        }\n        // Add a small delay to ensure the component is fully rendered on client side\n        setTimeout(async () => {\n            try {\n                console.log('Starting OAuth2 callback processing...');\n                console.log('Current URL:', window.location.href);\n                console.log('LocalStorage available:', typeof (Storage) !== \"undefined\");\n                // Handle the OAuth2 callback\n                await this.oauth2Service.handleCallback();\n                // Success\n                this.isLoading = false;\n                this.success = true;\n                // Redirect after a short delay\n                setTimeout(() => {\n                    // You can customize this redirect logic based on your needs\n                    // For example, redirect to a specific route or emit an event\n                    this.router.navigate(['/']);\n                }, 2000);\n            }\n            catch (error) {\n                console.error('OAuth2 callback error:', error);\n                this.isLoading = false;\n                this.error = error instanceof Error ? error.message : 'Authentication failed';\n            }\n        }, 100);\n    }\n    retryLogin() {\n        if (!this.oauth2Service.isAuthenticationAvailable()) {\n            this.error = 'Authentication not available in current environment';\n            return;\n        }\n        this.isLoading = true;\n        this.error = null;\n        this.success = false;\n        this.oauth2Service.startAuthorization().catch(error => {\n            console.error('Retry login error:', error);\n            this.isLoading = false;\n            this.error = 'Failed to start authentication';\n        });\n    }\n    goHome() {\n        this.router.navigate(['/']);\n    }\n    static { this.ɵfac = function OAuth2CallbackComponent_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || OAuth2CallbackComponent)(i0.ɵɵdirectiveInject(OAuth2Service), i0.ɵɵdirectiveInject(i2.Router), i0.ɵɵdirectiveInject(PLATFORM_ID)); }; }\n    static { this.ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: OAuth2CallbackComponent, selectors: [[\"lib-oauth2-callback\"]], decls: 5, vars: 3, consts: [[1, \"oauth2-callback-container\"], [1, \"oauth2-callback-content\"], [\"class\", \"loading-section\", 4, \"ngIf\"], [\"class\", \"success-section\", 4, \"ngIf\"], [\"class\", \"error-section\", 4, \"ngIf\"], [1, \"loading-section\"], [1, \"spinner\"], [1, \"success-section\"], [1, \"success-icon\"], [1, \"error-section\"], [1, \"error-icon\"], [1, \"error-message\"], [1, \"error-actions\"], [1, \"retry-button\", 3, \"click\"], [1, \"home-button\", 3, \"click\"]], template: function OAuth2CallbackComponent_Template(rf, ctx) { if (rf & 1) {\n            i0.ɵɵelementStart(0, \"div\", 0)(1, \"div\", 1);\n            i0.ɵɵtemplate(2, OAuth2CallbackComponent_div_2_Template, 6, 0, \"div\", 2)(3, OAuth2CallbackComponent_div_3_Template, 7, 0, \"div\", 3)(4, OAuth2CallbackComponent_div_4_Template, 12, 1, \"div\", 4);\n            i0.ɵɵelementEnd()();\n        } if (rf & 2) {\n            i0.ɵɵadvance(2);\n            i0.ɵɵproperty(\"ngIf\", ctx.isLoading);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.success && !ctx.isLoading);\n            i0.ɵɵadvance();\n            i0.ɵɵproperty(\"ngIf\", ctx.error && !ctx.isLoading);\n        } }, dependencies: [CommonModule, i3.NgIf], styles: [\".oauth2-callback-container[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;min-height:100vh;background-color:#f5f5f5;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif}.oauth2-callback-content[_ngcontent-%COMP%]{background:#fff;border-radius:8px;padding:2rem;box-shadow:0 4px 6px #0000001a;text-align:center;max-width:400px;width:100%;margin:1rem}.loading-section[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%], .success-section[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%], .error-section[_ngcontent-%COMP%]   h2[_ngcontent-%COMP%]{margin:1rem 0 .5rem;color:#333}.loading-section[_ngcontent-%COMP%]   p[_ngcontent-%COMP%], .success-section[_ngcontent-%COMP%]   p[_ngcontent-%COMP%]{color:#666;margin-bottom:0}.spinner[_ngcontent-%COMP%]{border:3px solid #f3f3f3;border-top:3px solid #007bff;border-radius:50%;width:40px;height:40px;animation:_ngcontent-%COMP%_spin 1s linear infinite;margin:0 auto 1rem}@keyframes _ngcontent-%COMP%_spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.success-icon[_ngcontent-%COMP%]{width:60px;height:60px;border-radius:50%;background-color:#28a745;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2rem;font-weight:700;margin:0 auto 1rem}.error-icon[_ngcontent-%COMP%]{width:60px;height:60px;border-radius:50%;background-color:#dc3545;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2rem;font-weight:700;margin:0 auto 1rem}.error-message[_ngcontent-%COMP%]{color:#dc3545;margin:1rem 0;padding:.5rem;background-color:#f8d7da;border:1px solid #f5c6cb;border-radius:4px;font-size:.9rem}.error-actions[_ngcontent-%COMP%]{display:flex;gap:1rem;justify-content:center;margin-top:1.5rem}.retry-button[_ngcontent-%COMP%], .home-button[_ngcontent-%COMP%]{padding:.75rem 1.5rem;border:none;border-radius:4px;cursor:pointer;font-size:.9rem;font-weight:500;transition:background-color .2s}.retry-button[_ngcontent-%COMP%]{background-color:#007bff;color:#fff}.retry-button[_ngcontent-%COMP%]:hover{background-color:#0056b3}.home-button[_ngcontent-%COMP%]{background-color:#6c757d;color:#fff}.home-button[_ngcontent-%COMP%]:hover{background-color:#545b62}@media (max-width: 480px){.oauth2-callback-content[_ngcontent-%COMP%]{margin:.5rem;padding:1.5rem}.error-actions[_ngcontent-%COMP%]{flex-direction:column}.retry-button[_ngcontent-%COMP%], .home-button[_ngcontent-%COMP%]{width:100%}}\"] }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(OAuth2CallbackComponent, [{\n        type: Component,\n        args: [{ selector: 'lib-oauth2-callback', standalone: true, imports: [CommonModule], template: `\r\n    <div class=\"oauth2-callback-container\">\r\n      <div class=\"oauth2-callback-content\">\r\n        <div *ngIf=\"isLoading\" class=\"loading-section\">\r\n          <div class=\"spinner\"></div>\r\n          <h2>Processing Authentication...</h2>\r\n          <p>Please wait while we complete your login.</p>\r\n        </div>\r\n\r\n        <div *ngIf=\"success && !isLoading\" class=\"success-section\">\r\n          <div class=\"success-icon\">✓</div>\r\n          <h2>Authentication Successful!</h2>\r\n          <p>You will be redirected shortly...</p>\r\n        </div>\r\n\r\n        <div *ngIf=\"error && !isLoading\" class=\"error-section\">\r\n          <div class=\"error-icon\">✗</div>\r\n          <h2>Authentication Failed</h2>\r\n          <p class=\"error-message\">{{ error }}</p>\r\n          <div class=\"error-actions\">\r\n            <button (click)=\"retryLogin()\" class=\"retry-button\">\r\n              Try Again\r\n            </button>\r\n            <button (click)=\"goHome()\" class=\"home-button\">\r\n              Go Home\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  `, styles: [\".oauth2-callback-container{display:flex;justify-content:center;align-items:center;min-height:100vh;background-color:#f5f5f5;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif}.oauth2-callback-content{background:#fff;border-radius:8px;padding:2rem;box-shadow:0 4px 6px #0000001a;text-align:center;max-width:400px;width:100%;margin:1rem}.loading-section h2,.success-section h2,.error-section h2{margin:1rem 0 .5rem;color:#333}.loading-section p,.success-section p{color:#666;margin-bottom:0}.spinner{border:3px solid #f3f3f3;border-top:3px solid #007bff;border-radius:50%;width:40px;height:40px;animation:spin 1s linear infinite;margin:0 auto 1rem}@keyframes spin{0%{transform:rotate(0)}to{transform:rotate(360deg)}}.success-icon{width:60px;height:60px;border-radius:50%;background-color:#28a745;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2rem;font-weight:700;margin:0 auto 1rem}.error-icon{width:60px;height:60px;border-radius:50%;background-color:#dc3545;color:#fff;display:flex;align-items:center;justify-content:center;font-size:2rem;font-weight:700;margin:0 auto 1rem}.error-message{color:#dc3545;margin:1rem 0;padding:.5rem;background-color:#f8d7da;border:1px solid #f5c6cb;border-radius:4px;font-size:.9rem}.error-actions{display:flex;gap:1rem;justify-content:center;margin-top:1.5rem}.retry-button,.home-button{padding:.75rem 1.5rem;border:none;border-radius:4px;cursor:pointer;font-size:.9rem;font-weight:500;transition:background-color .2s}.retry-button{background-color:#007bff;color:#fff}.retry-button:hover{background-color:#0056b3}.home-button{background-color:#6c757d;color:#fff}.home-button:hover{background-color:#545b62}@media (max-width: 480px){.oauth2-callback-content{margin:.5rem;padding:1.5rem}.error-actions{flex-direction:column}.retry-button,.home-button{width:100%}}\\n\"] }]\n    }], () => [{ type: OAuth2Service }, { type: i2.Router }, { type: Object, decorators: [{\n                type: Inject,\n                args: [PLATFORM_ID]\n            }] }], null); })();\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassDebugInfo(OAuth2CallbackComponent, { className: \"OAuth2CallbackComponent\", filePath: \"lib/components/oauth2-callback/oauth2-callback.component.ts\", lineNumber: 185 }); })();\n\n/**\n * OAuth2 Authentication Guard Function\n * Protects routes by checking if user is authenticated\n */\nconst oauth2AuthGuard = (route, state) => {\n    const oauth2Service = inject(OAuth2Service);\n    const router = inject(Router);\n    // Check if authentication is available in current environment\n    if (!oauth2Service.isAuthenticationAvailable()) {\n        console.warn('[OAuth2AuthGuard] Authentication not available in current environment');\n        return false;\n    }\n    // Check current authentication state\n    return oauth2Service.authState$.pipe(take(1), map(authState => {\n        if (authState.isAuthenticated) {\n            return true;\n        }\n        // Check if we have stored tokens that might be valid\n        if (oauth2Service.isAuthenticated()) {\n            return true;\n        }\n        // User is not authenticated, redirect to login or start OAuth flow\n        console.log('[OAuth2AuthGuard] User not authenticated, starting OAuth2 flow');\n        // You can customize this behavior:\n        // Option 1: Start OAuth2 flow immediately\n        oauth2Service.startAuthorization().catch(error => {\n            console.error('[OAuth2AuthGuard] Failed to start OAuth2 flow:', error);\n        });\n        // Option 2: Redirect to a login page\n        // router.navigate(['/login'], { queryParams: { returnUrl: state.url } });\n        return false;\n    }));\n};\n/**\n * OAuth2 Authentication Guard Class (for backward compatibility)\n * @deprecated Use oauth2AuthGuard function instead\n */\nclass OAuth2AuthGuard {\n    constructor(oauth2Service, router) {\n        this.oauth2Service = oauth2Service;\n        this.router = router;\n    }\n    canActivate(route, state) {\n        // Check if authentication is available in current environment\n        if (!this.oauth2Service.isAuthenticationAvailable()) {\n            console.warn('[OAuth2AuthGuard] Authentication not available in current environment');\n            return false;\n        }\n        // Check current authentication state\n        return this.oauth2Service.authState$.pipe(take(1), map(authState => {\n            if (authState.isAuthenticated) {\n                return true;\n            }\n            // Check if we have stored tokens that might be valid\n            if (this.oauth2Service.isAuthenticated()) {\n                return true;\n            }\n            // User is not authenticated, redirect to login or start OAuth flow\n            console.log('[OAuth2AuthGuard] User not authenticated, starting OAuth2 flow');\n            this.oauth2Service.startAuthorization().catch(error => {\n                console.error('[OAuth2AuthGuard] Failed to start OAuth2 flow:', error);\n            });\n            return false;\n        }));\n    }\n}\n/**\n * OAuth2 Unauthenticated Guard Function\n * Protects routes that should only be accessible to unauthenticated users\n * (e.g., login page, registration page)\n */\nconst oauth2UnauthGuard = (route, state) => {\n    const oauth2Service = inject(OAuth2Service);\n    const router = inject(Router);\n    // Check if authentication is available in current environment\n    if (!oauth2Service.isAuthenticationAvailable()) {\n        return true; // Allow access if auth is not available\n    }\n    // Check current authentication state\n    return oauth2Service.authState$.pipe(take(1), map(authState => {\n        if (!authState.isAuthenticated && !oauth2Service.isAuthenticated()) {\n            return true; // User is not authenticated, allow access\n        }\n        // User is authenticated, redirect to protected area\n        console.log('[OAuth2UnauthGuard] User already authenticated, redirecting');\n        router.navigate(['/']); // Redirect to home or dashboard\n        return false;\n    }));\n};\nfunction oauth2RoleGuard(config) {\n    return (route, state) => {\n        const oauth2Service = inject(OAuth2Service);\n        const router = inject(Router);\n        // First check if user is authenticated\n        if (!oauth2Service.isAuthenticated()) {\n            console.log('[OAuth2RoleGuard] User not authenticated');\n            oauth2Service.startAuthorization().catch(error => {\n                console.error('[OAuth2RoleGuard] Failed to start OAuth2 flow:', error);\n            });\n            return false;\n        }\n        // If no roles or permissions specified, just check authentication\n        if (!config.roles?.length && !config.permissions?.length) {\n            return true;\n        }\n        // Get user info to check roles/permissions\n        return oauth2Service.getUserInfo().then(userInfo => {\n            const userRoles = userInfo.roles || [];\n            const userPermissions = userInfo.permissions || [];\n            let hasRequiredRoles = true;\n            let hasRequiredPermissions = true;\n            // Check roles\n            if (config.roles?.length) {\n                if (config.requireAll) {\n                    hasRequiredRoles = config.roles.every(role => userRoles.includes(role));\n                }\n                else {\n                    hasRequiredRoles = config.roles.some(role => userRoles.includes(role));\n                }\n            }\n            // Check permissions\n            if (config.permissions?.length) {\n                if (config.requireAll) {\n                    hasRequiredPermissions = config.permissions.every(permission => userPermissions.includes(permission));\n                }\n                else {\n                    hasRequiredPermissions = config.permissions.some(permission => userPermissions.includes(permission));\n                }\n            }\n            const hasAccess = hasRequiredRoles && hasRequiredPermissions;\n            if (!hasAccess) {\n                console.warn('[OAuth2RoleGuard] User does not have required roles/permissions');\n                router.navigate(['/unauthorized']); // Redirect to unauthorized page\n            }\n            return hasAccess;\n        }).catch(error => {\n            console.error('[OAuth2RoleGuard] Failed to get user info:', error);\n            return false;\n        });\n    };\n}\n\n/**\n * Provide OAuth2 configuration and services\n * Use this function in your app.config.ts or main.ts\n */\nfunction provideOAuth2(config) {\n    return makeEnvironmentProviders([\n        // Provide the OAuth2 configuration\n        { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\n        // Provide the OAuth2 services\n        OAuth2Service,\n        OAuth2StorageService,\n        // Provide HTTP client with OAuth2 interceptor\n        provideHttpClient(withInterceptors([oauth2InterceptorFn]))\n    ]);\n}\n/**\n * Provide OAuth2 configuration and services without HTTP interceptor\n * Use this if you want to manually configure the HTTP interceptor\n */\nfunction provideOAuth2WithoutInterceptor(config) {\n    return makeEnvironmentProviders([\n        // Provide the OAuth2 configuration\n        { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\n        // Provide the OAuth2 services\n        OAuth2Service,\n        OAuth2StorageService\n    ]);\n}\nclass NgOAuth2PkceModule {\n    static forRoot(config) {\n        return {\n            ngModule: NgOAuth2PkceModule,\n            providers: [\n                { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\n                OAuth2Service,\n                OAuth2StorageService\n            ]\n        };\n    }\n    static { this.ɵfac = function NgOAuth2PkceModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || NgOAuth2PkceModule)(); }; }\n    static { this.ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: NgOAuth2PkceModule }); }\n    static { this.ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [CommonModule] }); }\n}\n(() => { (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(NgOAuth2PkceModule, [{\n        type: NgModule,\n        args: [{\n                imports: [CommonModule],\n                exports: []\n            }]\n    }], null, null); })();\n(function () { (typeof ngJitMode === \"undefined\" || ngJitMode) && i0.ɵɵsetNgModuleScope(NgOAuth2PkceModule, { imports: [CommonModule] }); })();\n\n/*\n * Public API Surface of ng-oauth2-pkce\n */\n// Export models\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { NgOAuth2PkceModule, OAUTH2_CONFIG_TOKEN, OAUTH2_STORAGE_KEYS, OAuth2AuthGuard, OAuth2CallbackComponent, OAuth2Service, OAuth2StorageService, oauth2AuthGuard, oauth2InterceptorFn, oauth2RoleGuard, oauth2UnauthGuard, provideOAuth2, provideOAuth2WithoutInterceptor };\n//# sourceMappingURL=witspry-auth-ng-client.mjs.map\n","map":null,"preliminaryFileName":"witspry-auth-ng-client.mjs","sourcemapFileName":"witspry-auth-ng-client.mjs.map"},{"fileName":"witspry-auth-ng-client.mjs.map","names":[],"needsCodeReference":false,"originalFileName":null,"originalFileNames":[],"source":"{\"version\":3,\"file\":\"witspry-auth-ng-client.mjs\",\"sources\":[\"../../../src/lib/models/oauth2-types.model.ts\",\"../../../src/lib/tokens/oauth2-config.token.ts\",\"../../../src/lib/services/oauth2-storage.service.ts\",\"../../../src/lib/services/oauth2.service.ts\",\"../../../src/lib/interceptors/oauth2.interceptor.ts\",\"../../../src/lib/components/oauth2-callback/oauth2-callback.component.ts\",\"../../../src/lib/guards/oauth2-auth.guard.ts\",\"../../../src/lib/ng-oauth2-pkce.service.ts\",\"../../../src/public-api.ts\",\"../../../src/witspry-auth-ng-client.ts\"],\"sourcesContent\":[\"/**\\r\\n * PKCE Challenge Interface\\r\\n */\\r\\nexport interface PKCEChallenge {\\r\\n  codeVerifier: string;\\r\\n  codeChallenge: string;\\r\\n  codeChallengeMethod: string;\\r\\n}\\r\\n\\r\\n/**\\r\\n * OAuth2 Authorization Request Interface\\r\\n */\\r\\nexport interface AuthorizationRequest {\\r\\n  client_id: string;\\r\\n  redirect_uri: string;\\r\\n  response_type: string;\\r\\n  nonce: string;\\r\\n  audience?: string;\\r\\n  scope: string;\\r\\n  code_challenge_method: string;\\r\\n  code_challenge: string;\\r\\n  state?: string;\\r\\n}\\r\\n\\r\\n/**\\r\\n * OAuth2 Token Request Interface\\r\\n */\\r\\nexport interface TokenRequest {\\r\\n  grant_type: string;\\r\\n  redirect_uri: string;\\r\\n  client_id: string;\\r\\n  code: string;\\r\\n  code_verifier: string;\\r\\n}\\r\\n\\r\\n/**\\r\\n * OAuth2 Token Response Interface\\r\\n */\\r\\nexport interface TokenResponse {\\r\\n  access_token: string;\\r\\n  refresh_token?: string;\\r\\n  token_type: string;\\r\\n  expires_in: number;\\r\\n  scope?: string;\\r\\n  id_token?: string;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Token Information Interface\\r\\n */\\r\\nexport interface TokenInfo {\\r\\n  accessToken: string;\\r\\n  refreshToken?: string;\\r\\n  tokenType: string;\\r\\n  expiresAt: number;\\r\\n  scope?: string;\\r\\n  idToken?: string;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Authentication State Interface\\r\\n */\\r\\nexport interface AuthState {\\r\\n  isAuthenticated: boolean;\\r\\n  isLoading: boolean;\\r\\n  error?: string;\\r\\n  tokenInfo?: TokenInfo;\\r\\n}\\r\\n\\r\\n/**\\r\\n * OAuth2 Error Interface\\r\\n */\\r\\nexport interface OAuth2Error {\\r\\n  error: string;\\r\\n  error_description?: string;\\r\\n  error_uri?: string;\\r\\n  state?: string;\\r\\n}\\r\\n\\r\\n/**\\r\\n * User Information Response Interface\\r\\n */\\r\\nexport interface UserInfoResponse {\\r\\n  sub: string;\\r\\n  name?: string;\\r\\n  given_name?: string;\\r\\n  family_name?: string;\\r\\n  middle_name?: string;\\r\\n  nickname?: string;\\r\\n  preferred_username?: string;\\r\\n  profile?: string;\\r\\n  picture?: string;\\r\\n  website?: string;\\r\\n  email?: string;\\r\\n  email_verified?: boolean;\\r\\n  gender?: string;\\r\\n  birthdate?: string;\\r\\n  zoneinfo?: string;\\r\\n  locale?: string;\\r\\n  phone_number?: string;\\r\\n  phone_number_verified?: boolean;\\r\\n  address?: {\\r\\n    formatted?: string;\\r\\n    street_address?: string;\\r\\n    locality?: string;\\r\\n    region?: string;\\r\\n    postal_code?: string;\\r\\n    country?: string;\\r\\n  };\\r\\n  updated_at?: number;\\r\\n  [key: string]: any;\\r\\n}\\r\\n\\r\\n/**\\r\\n * OAuth2 Storage Keys Constants\\r\\n */\\r\\nexport const OAUTH2_STORAGE_KEYS = {\\r\\n  CODE_VERIFIER: 'oauth2_code_verifier',\\r\\n  STATE: 'oauth2_state',\\r\\n  ACCESS_TOKEN: 'oauth2_access_token',\\r\\n  REFRESH_TOKEN: 'oauth2_refresh_token',\\r\\n  TOKEN_EXPIRES_AT: 'oauth2_token_expires_at',\\r\\n  TOKEN_TYPE: 'oauth2_token_type',\\r\\n  SCOPE: 'oauth2_scope',\\r\\n  ID_TOKEN: 'oauth2_id_token',\\r\\n  NONCE: 'oauth2_nonce'\\r\\n} as const;\\r\\n\\r\\n/**\\r\\n * OAuth2 Log Levels\\r\\n */\\r\\nexport type OAuth2LogLevel = 'none' | 'error' | 'warn' | 'info' | 'debug';\\r\\n\\r\\n/**\\r\\n * OAuth2 Events\\r\\n */\\r\\nexport interface OAuth2Events {\\r\\n  tokenRefreshed: TokenInfo;\\r\\n  tokenExpired: void;\\r\\n  authenticationFailed: OAuth2Error;\\r\\n  userLoggedOut: void;\\r\\n}\",\"import { InjectionToken } from '@angular/core';\\r\\nimport { OAuth2Config } from '../models/oauth2-config.model';\\r\\n\\r\\n/**\\r\\n * Injection token for OAuth2 configuration\\r\\n */\\r\\nexport const OAUTH2_CONFIG_TOKEN = new InjectionToken<OAuth2Config>('OAUTH2_CONFIG');\",\"import { Injectable, Inject, PLATFORM_ID } from '@angular/core';\\r\\nimport { isPlatformBrowser } from '@angular/common';\\r\\nimport { OAuth2Config, OAuth2Storage } from '../models/oauth2-config.model';\\r\\nimport { OAUTH2_STORAGE_KEYS, OAuth2LogLevel } from '../models/oauth2-types.model';\\r\\nimport { OAUTH2_CONFIG_TOKEN } from '../tokens/oauth2-config.token';\\r\\n\\r\\n/**\\r\\n * OAuth2 Storage Service\\r\\n * Handles secure storage and retrieval of OAuth2 tokens and data\\r\\n */\\r\\n@Injectable({\\r\\n  providedIn: 'root'\\r\\n})\\r\\nexport class OAuth2StorageService {\\r\\n  private storage: OAuth2Storage;\\r\\n  private logLevel: OAuth2LogLevel;\\r\\n\\r\\n  constructor(\\r\\n    @Inject(OAUTH2_CONFIG_TOKEN) private config: OAuth2Config,\\r\\n    @Inject(PLATFORM_ID) private platformId: Object\\r\\n  ) {\\r\\n    this.logLevel = config.logLevel || 'warn';\\r\\n    this.storage = this.initializeStorage();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Initialize storage based on configuration\\r\\n   */\\r\\n  private initializeStorage(): OAuth2Storage {\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      // Return a no-op storage for SSR\\r\\n      return {\\r\\n        getItem: () => null,\\r\\n        setItem: () => {},\\r\\n        removeItem: () => {},\\r\\n        clear: () => {}\\r\\n      };\\r\\n    }\\r\\n\\r\\n    switch (this.config.storage) {\\r\\n      case 'sessionStorage':\\r\\n        return sessionStorage;\\r\\n      case 'custom':\\r\\n        if (!this.config.customStorage) {\\r\\n          this.logError('Custom storage specified but not provided');\\r\\n          return localStorage;\\r\\n        }\\r\\n        return this.config.customStorage;\\r\\n      case 'localStorage':\\r\\n      default:\\r\\n        return localStorage;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Store a value securely\\r\\n   */\\r\\n  setItem(key: string, value: string): void {\\r\\n    try {\\r\\n      // In production, consider encrypting sensitive values\\r\\n      this.storage.setItem(key, value);\\r\\n      this.logDebug(`Stored item with key: ${key}`);\\r\\n    } catch (error) {\\r\\n      this.logError('Error storing item:', error);\\r\\n      throw new Error('Failed to store item');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Retrieve a value securely\\r\\n   */\\r\\n  getItem(key: string): string | null {\\r\\n    try {\\r\\n      const value = this.storage.getItem(key);\\r\\n      this.logDebug(`Retrieved item with key: ${key}`, value ? 'Found' : 'Not found');\\r\\n      return value;\\r\\n    } catch (error) {\\r\\n      this.logError('Error retrieving item:', error);\\r\\n      return null;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Remove a specific item\\r\\n   */\\r\\n  removeItem(key: string): void {\\r\\n    try {\\r\\n      this.storage.removeItem(key);\\r\\n      this.logDebug(`Removed item with key: ${key}`);\\r\\n    } catch (error) {\\r\\n      this.logError('Error removing item:', error);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Clear all OAuth2 related storage\\r\\n   */\\r\\n  clearAll(): void {\\r\\n    try {\\r\\n      Object.values(OAUTH2_STORAGE_KEYS).forEach(key => {\\r\\n        this.storage.removeItem(key);\\r\\n      });\\r\\n      this.logDebug('Cleared all OAuth2 storage');\\r\\n    } catch (error) {\\r\\n      this.logError('Error clearing storage:', error);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Clear only token-related storage, preserve OAuth2 flow storage\\r\\n   */\\r\\n  clearTokens(): void {\\r\\n    try {\\r\\n      const tokenKeys = [\\r\\n        OAUTH2_STORAGE_KEYS.ACCESS_TOKEN,\\r\\n        OAUTH2_STORAGE_KEYS.REFRESH_TOKEN,\\r\\n        OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT,\\r\\n        OAUTH2_STORAGE_KEYS.TOKEN_TYPE,\\r\\n        OAUTH2_STORAGE_KEYS.SCOPE,\\r\\n        OAUTH2_STORAGE_KEYS.ID_TOKEN\\r\\n      ];\\r\\n      \\r\\n      tokenKeys.forEach(key => {\\r\\n        this.storage.removeItem(key);\\r\\n      });\\r\\n      \\r\\n      this.logDebug('Cleared token storage (OAuth2 flow storage preserved)');\\r\\n    } catch (error) {\\r\\n      this.logError('Error clearing token storage:', error);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Clear temporary OAuth2 flow storage\\r\\n   */\\r\\n  clearTemporary(): void {\\r\\n    try {\\r\\n      this.storage.removeItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER);\\r\\n      this.storage.removeItem(OAUTH2_STORAGE_KEYS.STATE);\\r\\n      this.storage.removeItem(OAUTH2_STORAGE_KEYS.NONCE);\\r\\n      this.logDebug('Cleared temporary OAuth2 storage');\\r\\n    } catch (error) {\\r\\n      this.logError('Error clearing temporary storage:', error);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Check if storage is available\\r\\n   */\\r\\n  isAvailable(): boolean {\\r\\n    return isPlatformBrowser(this.platformId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get all stored keys (for debugging)\\r\\n   */\\r\\n  getStoredKeys(): string[] {\\r\\n    if (!this.isAvailable()) {\\r\\n      return [];\\r\\n    }\\r\\n\\r\\n    try {\\r\\n      const keys: string[] = [];\\r\\n      for (let i = 0; i < (this.storage as any).length; i++) {\\r\\n        const key = (this.storage as any).key(i);\\r\\n        if (key && Object.values(OAUTH2_STORAGE_KEYS).includes(key)) {\\r\\n          keys.push(key);\\r\\n        }\\r\\n      }\\r\\n      return keys;\\r\\n    } catch (error) {\\r\\n      this.logError('Error getting stored keys:', error);\\r\\n      return [];\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Debug logging\\r\\n   */\\r\\n  private logDebug(message: string, ...args: any[]): void {\\r\\n    if (this.logLevel === 'debug') {\\r\\n      console.log(`[OAuth2StorageService] ${message}`, ...args);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Info logging\\r\\n   */\\r\\n  private logInfo(message: string, ...args: any[]): void {\\r\\n    if (['debug', 'info'].includes(this.logLevel)) {\\r\\n      console.info(`[OAuth2StorageService] ${message}`, ...args);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Warning logging\\r\\n   */\\r\\n  private logWarn(message: string, ...args: any[]): void {\\r\\n    if (['debug', 'info', 'warn'].includes(this.logLevel)) {\\r\\n      console.warn(`[OAuth2StorageService] ${message}`, ...args);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Error logging\\r\\n   */\\r\\n  private logError(message: string, error?: any): void {\\r\\n    if (this.logLevel !== 'none') {\\r\\n      console.error(`[OAuth2StorageService] ${message}`, error);\\r\\n    }\\r\\n  }\\r\\n}\",\"import { Injectable, Inject, PLATFORM_ID, signal } from '@angular/core';\\r\\nimport { isPlatformBrowser } from '@angular/common';\\r\\nimport { HttpClient } from '@angular/common/http';\\r\\nimport { Router } from '@angular/router';\\r\\nimport { Observable, BehaviorSubject, throwError, of } from 'rxjs';\\r\\nimport { map, catchError, tap } from 'rxjs/operators';\\r\\n\\r\\nimport { OAuth2Config } from '../models/oauth2-config.model';\\r\\nimport {\\r\\n  PKCEChallenge,\\r\\n  AuthorizationRequest,\\r\\n  TokenRequest,\\r\\n  TokenResponse,\\r\\n  TokenInfo,\\r\\n  AuthState,\\r\\n  OAuth2Error,\\r\\n  OAUTH2_STORAGE_KEYS,\\r\\n  UserInfoResponse,\\r\\n  OAuth2LogLevel\\r\\n} from '../models/oauth2-types.model';\\r\\nimport { OAUTH2_CONFIG_TOKEN } from '../tokens/oauth2-config.token';\\r\\nimport { OAuth2StorageService } from './oauth2-storage.service';\\r\\n\\r\\n/**\\r\\n * OAuth2 Service with PKCE Support\\r\\n * Handles OAuth2 authorization flow, token management, and user authentication\\r\\n */\\r\\n@Injectable({\\r\\n  providedIn: 'root'\\r\\n})\\r\\nexport class OAuth2Service {\\r\\n  private _authState = signal<AuthState>({\\r\\n    isAuthenticated: false,\\r\\n    isLoading: false\\r\\n  });\\r\\n\\r\\n  private _authStateSubject = new BehaviorSubject<AuthState>({\\r\\n    isAuthenticated: false,\\r\\n    isLoading: false\\r\\n  });\\r\\n\\r\\n  public authState$ = this._authStateSubject.asObservable();\\r\\n  public readonly authState = this._authState.asReadonly();\\r\\n\\r\\n  private logLevel: OAuth2LogLevel;\\r\\n\\r\\n  constructor(\\r\\n    @Inject(OAUTH2_CONFIG_TOKEN) private config: OAuth2Config,\\r\\n    @Inject(PLATFORM_ID) private platformId: Object,\\r\\n    private http: HttpClient,\\r\\n    private router: Router,\\r\\n    private storageService: OAuth2StorageService\\r\\n  ) {\\r\\n    this.logLevel = config.logLevel || 'warn';\\r\\n    this.initializeAuthState();\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Initialize authentication state from stored tokens\\r\\n   */\\r\\n  private initializeAuthState(): void {\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n      const tokenInfo = this.getStoredTokenInfo();\\r\\n      if (tokenInfo && this.isTokenValid(tokenInfo)) {\\r\\n        this.updateAuthState({\\r\\n          isAuthenticated: true,\\r\\n          isLoading: false,\\r\\n          tokenInfo\\r\\n        });\\r\\n        this.logInfo('Authentication state initialized from stored tokens');\\r\\n      } else if (tokenInfo && tokenInfo.refreshToken) {\\r\\n        // Access token is expired but refresh token exists\\r\\n        this.logInfo('Access token expired but refresh token available - preserving for refresh flow');\\r\\n        this.updateAuthState({\\r\\n          isAuthenticated: false,\\r\\n          isLoading: false,\\r\\n          tokenInfo: undefined\\r\\n        });\\r\\n      } else {\\r\\n        // No tokens or no refresh token available - clear everything\\r\\n        this.storageService.clearTokens();\\r\\n        this.logInfo('No valid stored tokens found');\\r\\n      }\\r\\n    } catch (error) {\\r\\n      this.logError('Error initializing auth state:', error);\\r\\n      this.storageService.clearTokens();\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Generate cryptographically secure PKCE challenge\\r\\n   */\\r\\n  private async generatePKCEChallenge(): Promise<PKCEChallenge> {\\r\\n    const codeVerifier = this.generateSecureCodeVerifier();\\r\\n    const codeChallenge = await this.createCodeChallenge(codeVerifier);\\r\\n    \\r\\n    return {\\r\\n      codeVerifier,\\r\\n      codeChallenge,\\r\\n      codeChallengeMethod: this.config.codeChallengeMethod || 'S256'\\r\\n    };\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Generate cryptographically secure 6-digit code verifier\\r\\n   */\\r\\n  private generateSecureCodeVerifier(): string {\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      throw new Error('Code verifier generation requires browser environment');\\r\\n    }\\r\\n\\r\\n    // Generate 6 cryptographically secure random digits\\r\\n    const array = new Uint8Array(6);\\r\\n    crypto.getRandomValues(array);\\r\\n    \\r\\n    // Convert to 6-digit string (000000-999999)\\r\\n    const codeVerifier = Array.from(array)\\r\\n      .map(byte => (byte % 10).toString())\\r\\n      .join('');\\r\\n    \\r\\n    this.logDebug('Generated secure 6-digit code verifier');\\r\\n    return codeVerifier;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Create SHA-256 hash and base64 encode for code challenge\\r\\n   */\\r\\n  private async createCodeChallenge(codeVerifier: string): Promise<string> {\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      throw new Error('Code challenge creation requires browser environment');\\r\\n    }\\r\\n\\r\\n    try {\\r\\n      // Encode the code verifier as UTF-8\\r\\n      const encoder = new TextEncoder();\\r\\n      const data = encoder.encode(codeVerifier);\\r\\n      \\r\\n      // Create SHA-256 hash\\r\\n      const hashBuffer = await crypto.subtle.digest('SHA-256', data);\\r\\n      \\r\\n      // Convert to base64url encoding\\r\\n      const hashArray = new Uint8Array(hashBuffer);\\r\\n      const base64String = btoa(String.fromCharCode(...hashArray))\\r\\n        .replace(/\\\\+/g, '-')\\r\\n        .replace(/\\\\//g, '_')\\r\\n        .replace(/=/g, '');\\r\\n      \\r\\n      this.logDebug('Generated code challenge from verifier');\\r\\n      return base64String;\\r\\n    } catch (error) {\\r\\n      this.logError('Error creating code challenge:', error);\\r\\n      throw new Error('Failed to create code challenge');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Generate cryptographically secure state parameter for CSRF protection\\r\\n   */\\r\\n  private generateState(): string {\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      return 'fallback-state';\\r\\n    }\\r\\n\\r\\n    const array = new Uint8Array(32);\\r\\n    crypto.getRandomValues(array);\\r\\n    return btoa(String.fromCharCode(...array))\\r\\n      .replace(/\\\\+/g, '-')\\r\\n      .replace(/\\\\//g, '_')\\r\\n      .replace(/=/g, '');\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Generate nonce if not provided in config\\r\\n   */\\r\\n  private generateNonce(): string {\\r\\n    if (this.config.nonce) {\\r\\n      return this.config.nonce;\\r\\n    }\\r\\n\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      return 'fallback-nonce';\\r\\n    }\\r\\n\\r\\n    const array = new Uint8Array(16);\\r\\n    crypto.getRandomValues(array);\\r\\n    return btoa(String.fromCharCode(...array))\\r\\n      .replace(/\\\\+/g, '-')\\r\\n      .replace(/\\\\//g, '_')\\r\\n      .replace(/=/g, '');\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Start OAuth2 PKCE authorization flow\\r\\n   */\\r\\n  async startAuthorization(): Promise<void> {\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      this.logError('Authorization attempted in non-browser environment', 'SSR or server context detected');\\r\\n      this.updateAuthState({\\r\\n        isLoading: false,\\r\\n        error: 'Authentication not available in server environment'\\r\\n      });\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    try {\\r\\n      this.updateAuthState({ isLoading: true, error: undefined });\\r\\n      \\r\\n      // Generate PKCE challenge\\r\\n      const pkceChallenge = await this.generatePKCEChallenge();\\r\\n      \\r\\n      // Generate state for CSRF protection\\r\\n      const state = this.generateState();\\r\\n      \\r\\n      // Generate nonce\\r\\n      const nonce = this.generateNonce();\\r\\n      \\r\\n      // Store code verifier, state, and nonce securely\\r\\n      this.storageService.setItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER, pkceChallenge.codeVerifier);\\r\\n      this.storageService.setItem(OAUTH2_STORAGE_KEYS.STATE, state);\\r\\n      this.storageService.setItem(OAUTH2_STORAGE_KEYS.NONCE, nonce);\\r\\n      \\r\\n      // Build authorization request\\r\\n      const authRequest: AuthorizationRequest = {\\r\\n        client_id: this.config.clientId,\\r\\n        redirect_uri: this.config.redirectUri,\\r\\n        response_type: this.config.responseType || 'code',\\r\\n        nonce,\\r\\n        audience: this.config.audience,\\r\\n        scope: this.config.scope,\\r\\n        code_challenge_method: pkceChallenge.codeChallengeMethod,\\r\\n        code_challenge: pkceChallenge.codeChallenge,\\r\\n        state\\r\\n      };\\r\\n      \\r\\n      // Build authorization URL\\r\\n      const authUrl = this.buildAuthorizationUrl(authRequest);\\r\\n      \\r\\n      this.logInfo('Starting OAuth2 PKCE authorization flow');\\r\\n      this.logDebug('Authorization URL:', authUrl);\\r\\n      \\r\\n      // Redirect to authorization server\\r\\n      window.location.href = authUrl;\\r\\n      \\r\\n    } catch (error) {\\r\\n      this.logError('Error starting authorization:', error);\\r\\n      this.updateAuthState({ \\r\\n        isLoading: false, \\r\\n        error: 'Failed to start authorization flow' \\r\\n      });\\r\\n      throw error;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Build authorization URL with parameters\\r\\n   */\\r\\n  private buildAuthorizationUrl(request: AuthorizationRequest): string {\\r\\n    const params = new URLSearchParams();\\r\\n    \\r\\n    Object.entries(request).forEach(([key, value]) => {\\r\\n      if (value !== undefined) {\\r\\n        params.append(key, value.toString());\\r\\n      }\\r\\n    });\\r\\n    \\r\\n    return `${this.config.authorizationEndpoint}?${params.toString()}`;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Handle OAuth2 callback and extract tokens\\r\\n   */\\r\\n  async handleCallback(): Promise<void> {\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      throw new Error('Callback handling requires browser environment');\\r\\n    }\\r\\n\\r\\n    try {\\r\\n      this.updateAuthState({ isLoading: true, error: undefined });\\r\\n      \\r\\n      const currentUrl = window.location.href;\\r\\n      this.logInfo('Handling OAuth2 callback:', currentUrl);\\r\\n      \\r\\n      // Check for error in callback\\r\\n      const error = this.extractErrorFromCallback();\\r\\n      if (error) {\\r\\n        throw new Error(`OAuth2 Error: ${error.error} - ${error.error_description || 'Unknown error'}`);\\r\\n      }\\r\\n      \\r\\n      // Extract authorization code from query parameters or hash fragment\\r\\n      const authCode = this.extractAuthorizationCode();\\r\\n      this.logDebug('Extracted authorization code:', authCode ? 'Found' : 'Not found');\\r\\n      \\r\\n      if (authCode) {\\r\\n        await this.exchangeCodeForTokens(authCode);\\r\\n        return;\\r\\n      }\\r\\n      \\r\\n      // Extract tokens from URL fragment (implicit flow)\\r\\n      const tokens = this.extractTokensFromFragment();\\r\\n      this.logDebug('Extracted tokens from fragment:', tokens ? 'Found' : 'Not found');\\r\\n      \\r\\n      if (tokens) {\\r\\n        await this.handleTokenResponse(tokens);\\r\\n        return;\\r\\n      }\\r\\n      \\r\\n      throw new Error('No authorization code or tokens found in callback');\\r\\n      \\r\\n    } catch (error) {\\r\\n      this.logError('Error handling callback:', error);\\r\\n      this.updateAuthState({ \\r\\n        isLoading: false, \\r\\n        error: error instanceof Error ? error.message : 'Callback handling failed' \\r\\n      });\\r\\n      this.storageService.clearAll();\\r\\n      throw error;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Extract error from callback URL\\r\\n   */\\r\\n  private extractErrorFromCallback(): OAuth2Error | null {\\r\\n    const urlParams = new URLSearchParams(window.location.search);\\r\\n    const hashParams = new URLSearchParams(window.location.hash.substring(1));\\r\\n    \\r\\n    const error = urlParams.get('error') || hashParams.get('error');\\r\\n    if (error) {\\r\\n      return {\\r\\n        error,\\r\\n        error_description: urlParams.get('error_description') || hashParams.get('error_description') || undefined,\\r\\n        error_uri: urlParams.get('error_uri') || hashParams.get('error_uri') || undefined,\\r\\n        state: urlParams.get('state') || hashParams.get('state') || undefined\\r\\n      };\\r\\n    }\\r\\n    \\r\\n    return null;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Extract authorization code from query parameters\\r\\n   */\\r\\n  private extractAuthorizationCode(): string | null {\\r\\n    // First check query parameters\\r\\n    const urlParams = new URLSearchParams(window.location.search);\\r\\n    let code = urlParams.get('code');\\r\\n    \\r\\n    // If not found in query params, check hash fragment\\r\\n    if (!code && window.location.hash) {\\r\\n      const hashParams = new URLSearchParams(window.location.hash.substring(1));\\r\\n      code = hashParams.get('code');\\r\\n    }\\r\\n    \\r\\n    if (code) {\\r\\n      this.logDebug('Authorization code extracted from callback');\\r\\n      return code;\\r\\n    }\\r\\n    \\r\\n    return null;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Extract tokens from URL fragment\\r\\n   */\\r\\n  private extractTokensFromFragment(): TokenResponse | null {\\r\\n    const fragment = window.location.hash.substring(1);\\r\\n    if (!fragment) {\\r\\n      return null;\\r\\n    }\\r\\n    \\r\\n    const params = new URLSearchParams(fragment);\\r\\n    const accessToken = params.get('access_token');\\r\\n    \\r\\n    if (accessToken) {\\r\\n      this.logDebug('Tokens extracted from URL fragment');\\r\\n      return {\\r\\n        access_token: accessToken,\\r\\n        refresh_token: params.get('refresh_token') || undefined,\\r\\n        token_type: params.get('token_type') || 'Bearer',\\r\\n        expires_in: parseInt(params.get('expires_in') || '3600', 10),\\r\\n        scope: params.get('scope') || undefined,\\r\\n        id_token: params.get('id_token') || undefined\\r\\n      };\\r\\n    }\\r\\n    \\r\\n    return null;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Exchange authorization code for tokens\\r\\n   */\\r\\n  private async exchangeCodeForTokens(authCode: string): Promise<void> {\\r\\n    const codeVerifier = this.storageService.getItem(OAUTH2_STORAGE_KEYS.CODE_VERIFIER);\\r\\n    \\r\\n    if (!codeVerifier) {\\r\\n      this.logError('Code verifier not found in storage');\\r\\n      throw new Error('Code verifier not found in storage');\\r\\n    }\\r\\n    \\r\\n    const tokenRequest: TokenRequest = {\\r\\n      grant_type: 'authorization_code',\\r\\n      redirect_uri: this.config.redirectUri,\\r\\n      client_id: this.config.clientId,\\r\\n      code: authCode,\\r\\n      code_verifier: codeVerifier\\r\\n    };\\r\\n    \\r\\n    this.logInfo('Exchanging authorization code for tokens');\\r\\n    \\r\\n    // Convert to URL-encoded form data as per OAuth 2.0 standard\\r\\n    const formData = new URLSearchParams();\\r\\n    Object.entries(tokenRequest).forEach(([key, value]) => {\\r\\n      if (value !== undefined) {\\r\\n        formData.append(key, value.toString());\\r\\n      }\\r\\n    });\\r\\n    \\r\\n    try {\\r\\n      const tokenResponse = await this.http.post<TokenResponse>(\\r\\n        this.config.tokenEndpoint,\\r\\n        formData.toString(),\\r\\n        {\\r\\n          headers: {\\r\\n            'Content-Type': 'application/x-www-form-urlencoded'\\r\\n          }\\r\\n        }\\r\\n      ).toPromise();\\r\\n      \\r\\n      if (tokenResponse) {\\r\\n        await this.handleTokenResponse(tokenResponse);\\r\\n      } else {\\r\\n        throw new Error('No token response received');\\r\\n      }\\r\\n      \\r\\n    } catch (error) {\\r\\n      this.logError('Token exchange failed:', error);\\r\\n      throw new Error('Failed to exchange authorization code for tokens');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Handle token response and store tokens securely\\r\\n   */\\r\\n  private async handleTokenResponse(tokenResponse: TokenResponse): Promise<void> {\\r\\n    try {\\r\\n      // Validate state parameter for CSRF protection\\r\\n      await this.validateState();\\r\\n      \\r\\n      // Create token info\\r\\n      const tokenInfo: TokenInfo = {\\r\\n        accessToken: tokenResponse.access_token,\\r\\n        refreshToken: tokenResponse.refresh_token,\\r\\n        tokenType: tokenResponse.token_type || 'Bearer',\\r\\n        expiresAt: Date.now() + (tokenResponse.expires_in * 1000),\\r\\n        scope: tokenResponse.scope,\\r\\n        idToken: tokenResponse.id_token\\r\\n      };\\r\\n      \\r\\n      // Store tokens securely\\r\\n      this.storeTokenInfo(tokenInfo);\\r\\n      \\r\\n      // Update authentication state\\r\\n      this.updateAuthState({\\r\\n        isAuthenticated: true,\\r\\n        isLoading: false,\\r\\n        tokenInfo,\\r\\n        error: undefined\\r\\n      });\\r\\n      \\r\\n      // Clean up temporary storage\\r\\n      this.storageService.clearTemporary();\\r\\n      \\r\\n      this.logInfo('Tokens stored successfully, user authenticated');\\r\\n      \\r\\n    } catch (error) {\\r\\n      this.logError('Error handling token response:', error);\\r\\n      throw error;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Validate state parameter for CSRF protection\\r\\n   */\\r\\n  private async validateState(): Promise<void> {\\r\\n    const urlParams = new URLSearchParams(window.location.search);\\r\\n    const hashParams = new URLSearchParams(window.location.hash.substring(1));\\r\\n    \\r\\n    const receivedState = urlParams.get('state') || hashParams.get('state');\\r\\n    const storedState = this.storageService.getItem(OAUTH2_STORAGE_KEYS.STATE);\\r\\n    \\r\\n    if (!receivedState || !storedState || receivedState !== storedState) {\\r\\n      throw new Error('Invalid state parameter - possible CSRF attack');\\r\\n    }\\r\\n    \\r\\n    this.logDebug('State parameter validated successfully');\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get current access token (only if valid/not expired)\\r\\n   */\\r\\n  getAccessToken(): string | null {\\r\\n    const tokenInfo = this.getStoredTokenInfo();\\r\\n    if (tokenInfo && this.isTokenValid(tokenInfo)) {\\r\\n      return tokenInfo.accessToken;\\r\\n    }\\r\\n    return null;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get raw access token (even if expired) - used for refresh flow\\r\\n   */\\r\\n  getRawAccessToken(): string | null {\\r\\n    const tokenInfo = this.getStoredTokenInfo();\\r\\n    return tokenInfo?.accessToken || null;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Get current refresh token\\r\\n   */\\r\\n  getRefreshToken(): string | null {\\r\\n    const tokenInfo = this.getStoredTokenInfo();\\r\\n    return tokenInfo?.refreshToken || null;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Check if user is authenticated\\r\\n   */\\r\\n  isAuthenticated(): boolean {\\r\\n    const tokenInfo = this.getStoredTokenInfo();\\r\\n    return tokenInfo ? this.isTokenValid(tokenInfo) : false;\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Check if authentication is available in current environment\\r\\n   */\\r\\n  isAuthenticationAvailable(): boolean {\\r\\n    return isPlatformBrowser(this.platformId);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Fetch user information from OIDC userinfo endpoint\\r\\n   */\\r\\n  async getUserInfo(): Promise<UserInfoResponse> {\\r\\n    if (!this.config.userInfoEndpoint) {\\r\\n      throw new Error('UserInfo endpoint not configured');\\r\\n    }\\r\\n\\r\\n    const accessToken = this.getAccessToken();\\r\\n    if (!accessToken) {\\r\\n      throw new Error('No access token available');\\r\\n    }\\r\\n\\r\\n    this.logInfo('Fetching user info from OIDC userinfo endpoint');\\r\\n\\r\\n    try {\\r\\n      const userInfo = await this.http.get<UserInfoResponse>(\\r\\n        this.config.userInfoEndpoint,\\r\\n        {\\r\\n          headers: {\\r\\n            'Authorization': `Bearer ${accessToken}`\\r\\n          }\\r\\n        }\\r\\n      ).toPromise();\\r\\n\\r\\n      if (userInfo) {\\r\\n        this.logDebug('User info retrieved successfully:', userInfo);\\r\\n        return userInfo;\\r\\n      } else {\\r\\n        throw new Error('No user info response received');\\r\\n      }\\r\\n    } catch (error) {\\r\\n      this.logError('Failed to fetch user info:', error);\\r\\n      throw new Error('Failed to fetch user information');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Check if token is valid (not expired)\\r\\n   */\\r\\n  private isTokenValid(tokenInfo: TokenInfo): boolean {\\r\\n    const threshold = (this.config.refreshThreshold || 300) * 1000; // Convert to milliseconds\\r\\n    return Date.now() < (tokenInfo.expiresAt - threshold);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Refresh access token using refresh token\\r\\n   */\\r\\n  async refreshAccessToken(): Promise<string> {\\r\\n    const refreshToken = this.getRefreshToken();\\r\\n    if (!refreshToken) {\\r\\n      throw new Error('No refresh token available');\\r\\n    }\\r\\n    \\r\\n    this.logInfo('Refreshing access token');\\r\\n    \\r\\n    const tokenRequest = {\\r\\n      grant_type: 'refresh_token',\\r\\n      refresh_token: refreshToken,\\r\\n      client_id: this.config.clientId\\r\\n    };\\r\\n    \\r\\n    // Convert to URL-encoded form data as per OAuth 2.0 standard\\r\\n    const formData = new URLSearchParams();\\r\\n    Object.entries(tokenRequest).forEach(([key, value]) => {\\r\\n      if (value !== undefined) {\\r\\n        formData.append(key, value.toString());\\r\\n      }\\r\\n    });\\r\\n    \\r\\n    try {\\r\\n      const tokenResponse = await this.http.post<TokenResponse>(\\r\\n        this.config.tokenEndpoint,\\r\\n        formData.toString(),\\r\\n        {\\r\\n          headers: {\\r\\n            'Content-Type': 'application/x-www-form-urlencoded'\\r\\n          }\\r\\n        }\\r\\n      ).toPromise();\\r\\n      \\r\\n      if (tokenResponse) {\\r\\n        const tokenInfo: TokenInfo = {\\r\\n          accessToken: tokenResponse.access_token,\\r\\n          refreshToken: tokenResponse.refresh_token || refreshToken,\\r\\n          tokenType: tokenResponse.token_type || 'Bearer',\\r\\n          expiresAt: Date.now() + (tokenResponse.expires_in * 1000),\\r\\n          scope: tokenResponse.scope,\\r\\n          idToken: tokenResponse.id_token\\r\\n        };\\r\\n        \\r\\n        this.storeTokenInfo(tokenInfo);\\r\\n        this.updateAuthState({\\r\\n          isAuthenticated: true,\\r\\n          isLoading: false,\\r\\n          tokenInfo\\r\\n        });\\r\\n        \\r\\n        this.logInfo('Access token refreshed successfully');\\r\\n        return tokenResponse.access_token;\\r\\n      } else {\\r\\n        throw new Error('No token response received');\\r\\n      }\\r\\n      \\r\\n    } catch (error) {\\r\\n      this.logError('Token refresh failed:', error);\\r\\n      \\r\\n      // Only logout if it's a 400/401 error indicating invalid refresh token\\r\\n      if (error instanceof Error && 'status' in error) {\\r\\n        const httpError = error as any;\\r\\n        if (httpError.status === 400 || httpError.status === 401) {\\r\\n          this.logInfo('Refresh token is invalid, logging out');\\r\\n          this.logout();\\r\\n        }\\r\\n      } else {\\r\\n        this.logInfo('Network or server error during token refresh, will retry later');\\r\\n      }\\r\\n      \\r\\n      throw new Error('Failed to refresh access token');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Logout user and clean up all stored data\\r\\n   */\\r\\n  async logout(): Promise<void> {\\r\\n    try {\\r\\n      this.updateAuthState({ isLoading: true });\\r\\n      \\r\\n      // Revoke tokens if supported\\r\\n      await this.revokeTokens();\\r\\n      \\r\\n      // Clear all stored authentication data\\r\\n      this.storageService.clearAll();\\r\\n      \\r\\n      // Update authentication state\\r\\n      this.updateAuthState({\\r\\n        isAuthenticated: false,\\r\\n        isLoading: false,\\r\\n        tokenInfo: undefined,\\r\\n        error: undefined\\r\\n      });\\r\\n      \\r\\n      this.logInfo('User logged out successfully');\\r\\n      \\r\\n    } catch (error) {\\r\\n      this.logError('Error during logout:', error);\\r\\n      // Still clear local data even if revocation fails\\r\\n      this.storageService.clearAll();\\r\\n      this.updateAuthState({\\r\\n        isAuthenticated: false,\\r\\n        isLoading: false,\\r\\n        tokenInfo: undefined\\r\\n      });\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Revoke tokens at authorization server\\r\\n   */\\r\\n  private async revokeTokens(): Promise<void> {\\r\\n    if (!this.config.revokeEndpoint) {\\r\\n      this.logInfo('Token revocation endpoint not configured');\\r\\n      return;\\r\\n    }\\r\\n    \\r\\n    const accessToken = this.getAccessToken();\\r\\n    const refreshToken = this.getRefreshToken();\\r\\n    \\r\\n    const revokePromises: Promise<any>[] = [];\\r\\n    \\r\\n    if (accessToken) {\\r\\n      const revokeRequest = {\\r\\n        token: accessToken,\\r\\n        token_type_hint: 'access_token',\\r\\n        client_id: this.config.clientId\\r\\n      };\\r\\n      \\r\\n      const formData = new URLSearchParams();\\r\\n      Object.entries(revokeRequest).forEach(([key, value]) => {\\r\\n        if (value !== undefined) {\\r\\n          formData.append(key, value.toString());\\r\\n        }\\r\\n      });\\r\\n      \\r\\n      revokePromises.push(\\r\\n        this.http.post(this.config.revokeEndpoint, formData.toString(), {\\r\\n          headers: {\\r\\n            'Content-Type': 'application/x-www-form-urlencoded'\\r\\n          }\\r\\n        }).toPromise()\\r\\n      );\\r\\n    }\\r\\n    \\r\\n    if (refreshToken) {\\r\\n      const revokeRequest = {\\r\\n        token: refreshToken,\\r\\n        token_type_hint: 'refresh_token',\\r\\n        client_id: this.config.clientId\\r\\n      };\\r\\n      \\r\\n      const formData = new URLSearchParams();\\r\\n      Object.entries(revokeRequest).forEach(([key, value]) => {\\r\\n        if (value !== undefined) {\\r\\n          formData.append(key, value.toString());\\r\\n        }\\r\\n      });\\r\\n      \\r\\n      revokePromises.push(\\r\\n        this.http.post(this.config.revokeEndpoint, formData.toString(), {\\r\\n          headers: {\\r\\n            'Content-Type': 'application/x-www-form-urlencoded'\\r\\n          }\\r\\n        }).toPromise()\\r\\n      );\\r\\n    }\\r\\n    \\r\\n    if (revokePromises.length > 0) {\\r\\n      try {\\r\\n        await Promise.all(revokePromises);\\r\\n        this.logInfo('Tokens revoked successfully');\\r\\n      } catch (error) {\\r\\n        this.logError('Token revocation failed:', error);\\r\\n        // Don't throw error, continue with logout\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Store token information securely\\r\\n   */\\r\\n  private storeTokenInfo(tokenInfo: TokenInfo): void {\\r\\n    try {\\r\\n      this.storageService.setItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN, tokenInfo.accessToken);\\r\\n      this.storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT, tokenInfo.expiresAt.toString());\\r\\n      this.storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_TYPE, tokenInfo.tokenType);\\r\\n      \\r\\n      if (tokenInfo.refreshToken) {\\r\\n        this.storageService.setItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN, tokenInfo.refreshToken);\\r\\n      }\\r\\n      \\r\\n      if (tokenInfo.scope) {\\r\\n        this.storageService.setItem(OAUTH2_STORAGE_KEYS.SCOPE, tokenInfo.scope);\\r\\n      }\\r\\n      \\r\\n      if (tokenInfo.idToken) {\\r\\n        this.storageService.setItem(OAUTH2_STORAGE_KEYS.ID_TOKEN, tokenInfo.idToken);\\r\\n      }\\r\\n      \\r\\n      this.logDebug('Token information stored securely');\\r\\n    } catch (error) {\\r\\n      this.logError('Error storing token information:', error);\\r\\n      throw new Error('Failed to store token information');\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Retrieve stored token information\\r\\n   */\\r\\n  private getStoredTokenInfo(): TokenInfo | null {\\r\\n    if (!this.storageService.isAvailable()) {\\r\\n      return null;\\r\\n    }\\r\\n    \\r\\n    try {\\r\\n      const accessToken = this.storageService.getItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN);\\r\\n      const expiresAtStr = this.storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT);\\r\\n      \\r\\n      if (!accessToken || !expiresAtStr) {\\r\\n        return null;\\r\\n      }\\r\\n      \\r\\n      return {\\r\\n        accessToken,\\r\\n        refreshToken: this.storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN) || undefined,\\r\\n        tokenType: this.storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_TYPE) || 'Bearer',\\r\\n        expiresAt: parseInt(expiresAtStr, 10),\\r\\n        scope: this.storageService.getItem(OAUTH2_STORAGE_KEYS.SCOPE) || undefined,\\r\\n        idToken: this.storageService.getItem(OAUTH2_STORAGE_KEYS.ID_TOKEN) || undefined\\r\\n      };\\r\\n    } catch (error) {\\r\\n      this.logError('Error retrieving stored token information:', error);\\r\\n      return null;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Update authentication state\\r\\n   */\\r\\n  private updateAuthState(newState: Partial<AuthState>): void {\\r\\n    const currentState = this._authState();\\r\\n    const updatedState = { ...currentState, ...newState };\\r\\n    \\r\\n    this._authState.set(updatedState);\\r\\n    this._authStateSubject.next(updatedState);\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Debug logging\\r\\n   */\\r\\n  private logDebug(message: string, ...args: any[]): void {\\r\\n    if (this.logLevel === 'debug') {\\r\\n      console.log(`[OAuth2Service] ${message}`, ...args);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Info logging\\r\\n   */\\r\\n  private logInfo(message: string, ...args: any[]): void {\\r\\n    if (['debug', 'info'].includes(this.logLevel)) {\\r\\n      console.info(`[OAuth2Service] ${message}`, ...args);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Warning logging\\r\\n   */\\r\\n  private logWarn(message: string, ...args: any[]): void {\\r\\n    if (['debug', 'info', 'warn'].includes(this.logLevel)) {\\r\\n      console.warn(`[OAuth2Service] ${message}`, ...args);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /**\\r\\n   * Error logging\\r\\n   */\\r\\n  private logError(message: string, error?: any): void {\\r\\n    if (this.logLevel !== 'none') {\\r\\n      console.error(`[OAuth2Service] ${message}`, error);\\r\\n    }\\r\\n  }\\r\\n}\",\"import { inject, PLATFORM_ID } from '@angular/core';\\r\\nimport { isPlatformBrowser } from '@angular/common';\\r\\nimport {\\r\\n  HttpInterceptorFn,\\r\\n  HttpRequest,\\r\\n  HttpHandlerFn,\\r\\n  HttpEvent,\\r\\n  HttpErrorResponse,\\r\\n  HttpResponse,\\r\\n  HttpHeaders\\r\\n} from '@angular/common/http';\\r\\nimport { Observable, throwError, BehaviorSubject } from 'rxjs';\\r\\nimport { catchError, switchMap, filter, take } from 'rxjs/operators';\\r\\n\\r\\nimport { OAuth2Config } from '../models/oauth2-config.model';\\r\\nimport { OAUTH2_STORAGE_KEYS, OAuth2LogLevel } from '../models/oauth2-types.model';\\r\\nimport { OAUTH2_CONFIG_TOKEN } from '../tokens/oauth2-config.token';\\r\\nimport { OAuth2StorageService } from '../services/oauth2-storage.service';\\r\\n\\r\\n// Global state for token refresh\\r\\nlet isRefreshing = false;\\r\\nlet refreshTokenSubject: BehaviorSubject<any> = new BehaviorSubject<any>(null);\\r\\n\\r\\n/**\\r\\n * OAuth2 HTTP Interceptor Function\\r\\n * Automatically adds Bearer tokens to requests and handles token refresh\\r\\n */\\r\\nexport const oauth2InterceptorFn: HttpInterceptorFn = (\\r\\n  request: HttpRequest<any>,\\r\\n  next: HttpHandlerFn\\r\\n): Observable<HttpEvent<any>> => {\\r\\n  const platformId = inject(PLATFORM_ID);\\r\\n  const config = inject(OAUTH2_CONFIG_TOKEN);\\r\\n  const storageService = inject(OAuth2StorageService);\\r\\n  \\r\\n  const logLevel = config.logLevel || 'warn';\\r\\n\\r\\n  // Only intercept requests that should have OAuth2 tokens\\r\\n  if (!shouldInterceptRequest(request, config)) {\\r\\n    return next(request);\\r\\n  }\\r\\n\\r\\n  // Get access token directly from storage to avoid circular dependency\\r\\n  let accessToken = storageService.getItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN);\\r\\n  const hasValidToken = accessToken && isTokenValid(storageService);\\r\\n  \\r\\n  logDebug(logLevel, 'Access token retrieved:', accessToken ? (hasValidToken ? 'Valid' : 'Expired') : 'Not found');\\r\\n  logDebug(logLevel, 'Request URL:', request.url);\\r\\n  \\r\\n  // Always add token if available, even if expired (server will reject and we'll refresh)\\r\\n  if (accessToken) {\\r\\n    request = addTokenToRequest(request, accessToken);\\r\\n    logDebug(logLevel, 'Authorization header added to request');\\r\\n  } else {\\r\\n    logDebug(logLevel, 'No access token available, proceeding without Authorization header');\\r\\n  }\\r\\n\\r\\n  return next(request).pipe(\\r\\n    catchError((error: HttpErrorResponse) => {\\r\\n      // Handle 401 Unauthorized errors - attempt refresh if we have access token OR refresh token\\r\\n      if (error.status === 401) {\\r\\n        const refreshToken = storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN);\\r\\n        if (accessToken || refreshToken) {\\r\\n          logInfo(logLevel, '401 error detected, attempting token refresh');\\r\\n          logDebug(logLevel, 'Has access token:', !!accessToken, 'Has refresh token:', !!refreshToken);\\r\\n          return handle401Error(request, next, config, storageService, logLevel);\\r\\n        } else {\\r\\n          logInfo(logLevel, '401 error but no tokens available for refresh');\\r\\n        }\\r\\n      }\\r\\n      \\r\\n      return throwError(() => error);\\r\\n    })\\r\\n  );\\r\\n};\\r\\n\\r\\n/**\\r\\n * Check if token is valid (not expired)\\r\\n */\\r\\nfunction isTokenValid(storageService: OAuth2StorageService): boolean {\\r\\n  const expiresAtStr = storageService.getItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT);\\r\\n  if (!expiresAtStr) {\\r\\n    return false;\\r\\n  }\\r\\n  \\r\\n  const expiresAt = parseInt(expiresAtStr, 10);\\r\\n  return Date.now() < expiresAt;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Check if request should be intercepted\\r\\n */\\r\\nfunction shouldInterceptRequest(request: HttpRequest<any>, config: OAuth2Config): boolean {\\r\\n  // Exclude token refresh requests to avoid circular dependency\\r\\n  if (request.url === config.tokenEndpoint) {\\r\\n    return false;\\r\\n  }\\r\\n  \\r\\n  // Exclude revoke requests\\r\\n  if (config.revokeEndpoint && request.url === config.revokeEndpoint) {\\r\\n    return false;\\r\\n  }\\r\\n  \\r\\n  // You can customize this logic based on your needs\\r\\n  // For example, only intercept requests to specific domains or paths\\r\\n  return true;\\r\\n}\\r\\n\\r\\n/**\\r\\n * Add Bearer token to request headers\\r\\n */\\r\\nfunction addTokenToRequest(request: HttpRequest<any>, token: string): HttpRequest<any> {\\r\\n  return request.clone({\\r\\n    setHeaders: {\\r\\n      Authorization: `Bearer ${token}`\\r\\n    }\\r\\n  });\\r\\n}\\r\\n\\r\\n/**\\r\\n * Handle 401 Unauthorized errors by attempting token refresh\\r\\n */\\r\\nfunction handle401Error(\\r\\n  request: HttpRequest<any>,\\r\\n  next: HttpHandlerFn,\\r\\n  config: OAuth2Config,\\r\\n  storageService: OAuth2StorageService,\\r\\n  logLevel: OAuth2LogLevel\\r\\n): Observable<HttpEvent<any>> {\\r\\n  if (!isRefreshing) {\\r\\n    isRefreshing = true;\\r\\n    refreshTokenSubject.next(null);\\r\\n\\r\\n    const refreshToken = storageService.getItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN);\\r\\n    if (!refreshToken) {\\r\\n      isRefreshing = false;\\r\\n      logInfo(logLevel, 'No refresh token available');\\r\\n      return throwError(() => new Error('No refresh token available'));\\r\\n    }\\r\\n\\r\\n    // Create token refresh request directly using HttpRequest\\r\\n    const tokenRequestData = {\\r\\n      grant_type: 'refresh_token',\\r\\n      refresh_token: refreshToken,\\r\\n      client_id: config.clientId\\r\\n    };\\r\\n    \\r\\n    // Convert to URL-encoded form data as per OAuth 2.0 standard\\r\\n    const formData = new URLSearchParams();\\r\\n    Object.entries(tokenRequestData).forEach(([key, value]) => {\\r\\n      if (value !== undefined) {\\r\\n        formData.append(key, value.toString());\\r\\n      }\\r\\n    });\\r\\n    \\r\\n    const headers = new HttpHeaders({\\r\\n      'Content-Type': 'application/x-www-form-urlencoded'\\r\\n    });\\r\\n    \\r\\n    const refreshRequest = new HttpRequest('POST', config.tokenEndpoint, formData.toString(), {\\r\\n      headers: headers\\r\\n    });\\r\\n\\r\\n    return next(refreshRequest).pipe(\\r\\n      filter((event: HttpEvent<any>) => event instanceof HttpResponse),\\r\\n      switchMap((event: HttpResponse<any>) => {\\r\\n        const tokenResponse = event.body;\\r\\n        isRefreshing = false;\\r\\n        \\r\\n        if (tokenResponse?.access_token) {\\r\\n          // Store new tokens\\r\\n          storageService.setItem(OAUTH2_STORAGE_KEYS.ACCESS_TOKEN, tokenResponse.access_token);\\r\\n          storageService.setItem(OAUTH2_STORAGE_KEYS.TOKEN_EXPIRES_AT, (Date.now() + (tokenResponse.expires_in * 1000)).toString());\\r\\n          if (tokenResponse.refresh_token) {\\r\\n            storageService.setItem(OAUTH2_STORAGE_KEYS.REFRESH_TOKEN, tokenResponse.refresh_token);\\r\\n          }\\r\\n          \\r\\n          refreshTokenSubject.next(tokenResponse.access_token);\\r\\n          logInfo(logLevel, 'Token refreshed successfully, retrying original request');\\r\\n          \\r\\n          // Retry the original request with new token\\r\\n          return next(addTokenToRequest(request, tokenResponse.access_token));\\r\\n        } else {\\r\\n          throw new Error('No access token in refresh response');\\r\\n        }\\r\\n      }),\\r\\n      catchError(error => {\\r\\n        isRefreshing = false;\\r\\n        refreshTokenSubject.next(null);\\r\\n        \\r\\n        logError(logLevel, 'Token refresh failed:', error);\\r\\n        \\r\\n        // Check if it's an authentication error (invalid refresh token)\\r\\n        if (error?.status === 400 || error?.status === 401) {\\r\\n          logInfo(logLevel, 'Refresh token is invalid, clearing tokens');\\r\\n          \\r\\n          // Clear all OAuth2 tokens from storage\\r\\n          storageService.clearAll();\\r\\n          \\r\\n          // Optionally redirect to login or emit an event\\r\\n          // This depends on your application's requirements\\r\\n        } else {\\r\\n          logInfo(logLevel, 'Network/server error, not clearing tokens');\\r\\n        }\\r\\n        \\r\\n        return throwError(() => error);\\r\\n      })\\r\\n    );\\r\\n  } else {\\r\\n    // Wait for refresh to complete, then retry request\\r\\n    return refreshTokenSubject.pipe(\\r\\n      filter(token => token != null),\\r\\n      take(1),\\r\\n      switchMap(token => next(addTokenToRequest(request, token)))\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Debug logging\\r\\n */\\r\\nfunction logDebug(logLevel: OAuth2LogLevel, message: string, ...args: any[]): void {\\r\\n  if (logLevel === 'debug') {\\r\\n    console.log(`[OAuth2Interceptor] ${message}`, ...args);\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Info logging\\r\\n */\\r\\nfunction logInfo(logLevel: OAuth2LogLevel, message: string, ...args: any[]): void {\\r\\n  if (['debug', 'info'].includes(logLevel)) {\\r\\n    console.info(`[OAuth2Interceptor] ${message}`, ...args);\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * Error logging\\r\\n */\\r\\nfunction logError(logLevel: OAuth2LogLevel, message: string, error?: any): void {\\r\\n  if (logLevel !== 'none') {\\r\\n    console.error(`[OAuth2Interceptor] ${message}`, error);\\r\\n  }\\r\\n}\",\"import { Component, OnInit, Inject, PLATFORM_ID } from '@angular/core';\\r\\nimport { CommonModule, isPlatformBrowser } from '@angular/common';\\r\\nimport { Router } from '@angular/router';\\r\\nimport { OAuth2Service } from '../../services/oauth2.service';\\r\\n\\r\\n/**\\r\\n * OAuth2 Callback Component\\r\\n * Handles the OAuth2 authorization callback and processes the authorization code\\r\\n */\\r\\n@Component({\\r\\n  selector: 'lib-oauth2-callback',\\r\\n  standalone: true,\\r\\n  imports: [CommonModule],\\r\\n  template: `\\r\\n    <div class=\\\"oauth2-callback-container\\\">\\r\\n      <div class=\\\"oauth2-callback-content\\\">\\r\\n        <div *ngIf=\\\"isLoading\\\" class=\\\"loading-section\\\">\\r\\n          <div class=\\\"spinner\\\"></div>\\r\\n          <h2>Processing Authentication...</h2>\\r\\n          <p>Please wait while we complete your login.</p>\\r\\n        </div>\\r\\n\\r\\n        <div *ngIf=\\\"success && !isLoading\\\" class=\\\"success-section\\\">\\r\\n          <div class=\\\"success-icon\\\">✓</div>\\r\\n          <h2>Authentication Successful!</h2>\\r\\n          <p>You will be redirected shortly...</p>\\r\\n        </div>\\r\\n\\r\\n        <div *ngIf=\\\"error && !isLoading\\\" class=\\\"error-section\\\">\\r\\n          <div class=\\\"error-icon\\\">✗</div>\\r\\n          <h2>Authentication Failed</h2>\\r\\n          <p class=\\\"error-message\\\">{{ error }}</p>\\r\\n          <div class=\\\"error-actions\\\">\\r\\n            <button (click)=\\\"retryLogin()\\\" class=\\\"retry-button\\\">\\r\\n              Try Again\\r\\n            </button>\\r\\n            <button (click)=\\\"goHome()\\\" class=\\\"home-button\\\">\\r\\n              Go Home\\r\\n            </button>\\r\\n          </div>\\r\\n        </div>\\r\\n      </div>\\r\\n    </div>\\r\\n  `,\\r\\n  styles: [`\\r\\n    .oauth2-callback-container {\\r\\n      display: flex;\\r\\n      justify-content: center;\\r\\n      align-items: center;\\r\\n      min-height: 100vh;\\r\\n      background-color: #f5f5f5;\\r\\n      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;\\r\\n    }\\r\\n\\r\\n    .oauth2-callback-content {\\r\\n      background: white;\\r\\n      border-radius: 8px;\\r\\n      padding: 2rem;\\r\\n      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\\r\\n      text-align: center;\\r\\n      max-width: 400px;\\r\\n      width: 100%;\\r\\n      margin: 1rem;\\r\\n    }\\r\\n\\r\\n    .loading-section h2,\\r\\n    .success-section h2,\\r\\n    .error-section h2 {\\r\\n      margin: 1rem 0 0.5rem 0;\\r\\n      color: #333;\\r\\n    }\\r\\n\\r\\n    .loading-section p,\\r\\n    .success-section p {\\r\\n      color: #666;\\r\\n      margin-bottom: 0;\\r\\n    }\\r\\n\\r\\n    .spinner {\\r\\n      border: 3px solid #f3f3f3;\\r\\n      border-top: 3px solid #007bff;\\r\\n      border-radius: 50%;\\r\\n      width: 40px;\\r\\n      height: 40px;\\r\\n      animation: spin 1s linear infinite;\\r\\n      margin: 0 auto 1rem auto;\\r\\n    }\\r\\n\\r\\n    @keyframes spin {\\r\\n      0% { transform: rotate(0deg); }\\r\\n      100% { transform: rotate(360deg); }\\r\\n    }\\r\\n\\r\\n    .success-icon {\\r\\n      width: 60px;\\r\\n      height: 60px;\\r\\n      border-radius: 50%;\\r\\n      background-color: #28a745;\\r\\n      color: white;\\r\\n      display: flex;\\r\\n      align-items: center;\\r\\n      justify-content: center;\\r\\n      font-size: 2rem;\\r\\n      font-weight: bold;\\r\\n      margin: 0 auto 1rem auto;\\r\\n    }\\r\\n\\r\\n    .error-icon {\\r\\n      width: 60px;\\r\\n      height: 60px;\\r\\n      border-radius: 50%;\\r\\n      background-color: #dc3545;\\r\\n      color: white;\\r\\n      display: flex;\\r\\n      align-items: center;\\r\\n      justify-content: center;\\r\\n      font-size: 2rem;\\r\\n      font-weight: bold;\\r\\n      margin: 0 auto 1rem auto;\\r\\n    }\\r\\n\\r\\n    .error-message {\\r\\n      color: #dc3545;\\r\\n      margin: 1rem 0;\\r\\n      padding: 0.5rem;\\r\\n      background-color: #f8d7da;\\r\\n      border: 1px solid #f5c6cb;\\r\\n      border-radius: 4px;\\r\\n      font-size: 0.9rem;\\r\\n    }\\r\\n\\r\\n    .error-actions {\\r\\n      display: flex;\\r\\n      gap: 1rem;\\r\\n      justify-content: center;\\r\\n      margin-top: 1.5rem;\\r\\n    }\\r\\n\\r\\n    .retry-button,\\r\\n    .home-button {\\r\\n      padding: 0.75rem 1.5rem;\\r\\n      border: none;\\r\\n      border-radius: 4px;\\r\\n      cursor: pointer;\\r\\n      font-size: 0.9rem;\\r\\n      font-weight: 500;\\r\\n      transition: background-color 0.2s;\\r\\n    }\\r\\n\\r\\n    .retry-button {\\r\\n      background-color: #007bff;\\r\\n      color: white;\\r\\n    }\\r\\n\\r\\n    .retry-button:hover {\\r\\n      background-color: #0056b3;\\r\\n    }\\r\\n\\r\\n    .home-button {\\r\\n      background-color: #6c757d;\\r\\n      color: white;\\r\\n    }\\r\\n\\r\\n    .home-button:hover {\\r\\n      background-color: #545b62;\\r\\n    }\\r\\n\\r\\n    @media (max-width: 480px) {\\r\\n      .oauth2-callback-content {\\r\\n        margin: 0.5rem;\\r\\n        padding: 1.5rem;\\r\\n      }\\r\\n\\r\\n      .error-actions {\\r\\n        flex-direction: column;\\r\\n      }\\r\\n\\r\\n      .retry-button,\\r\\n      .home-button {\\r\\n        width: 100%;\\r\\n      }\\r\\n    }\\r\\n  `]\\r\\n})\\r\\nexport class OAuth2CallbackComponent implements OnInit {\\r\\n  isLoading = true;\\r\\n  error: string | null = null;\\r\\n  success = false;\\r\\n\\r\\n  constructor(\\r\\n    private oauth2Service: OAuth2Service,\\r\\n    private router: Router,\\r\\n    @Inject(PLATFORM_ID) private platformId: Object\\r\\n  ) {}\\r\\n\\r\\n  async ngOnInit(): Promise<void> {\\r\\n    // Only handle callback in browser environment\\r\\n    if (!isPlatformBrowser(this.platformId)) {\\r\\n      this.isLoading = false;\\r\\n      this.error = 'Browser environment required for OAuth2 callback';\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    // Add a small delay to ensure the component is fully rendered on client side\\r\\n    setTimeout(async () => {\\r\\n      try {\\r\\n        console.log('Starting OAuth2 callback processing...');\\r\\n        console.log('Current URL:', window.location.href);\\r\\n        console.log('LocalStorage available:', typeof(Storage) !== \\\"undefined\\\");\\r\\n        \\r\\n        // Handle the OAuth2 callback\\r\\n        await this.oauth2Service.handleCallback();\\r\\n        \\r\\n        // Success\\r\\n        this.isLoading = false;\\r\\n        this.success = true;\\r\\n        \\r\\n        // Redirect after a short delay\\r\\n        setTimeout(() => {\\r\\n          // You can customize this redirect logic based on your needs\\r\\n          // For example, redirect to a specific route or emit an event\\r\\n          this.router.navigate(['/']);\\r\\n        }, 2000);\\r\\n        \\r\\n      } catch (error) {\\r\\n        console.error('OAuth2 callback error:', error);\\r\\n        this.isLoading = false;\\r\\n        this.error = error instanceof Error ? error.message : 'Authentication failed';\\r\\n      }\\r\\n    }, 100);\\r\\n  }\\r\\n\\r\\n  retryLogin(): void {\\r\\n    if (!this.oauth2Service.isAuthenticationAvailable()) {\\r\\n      this.error = 'Authentication not available in current environment';\\r\\n      return;\\r\\n    }\\r\\n\\r\\n    this.isLoading = true;\\r\\n    this.error = null;\\r\\n    this.success = false;\\r\\n    \\r\\n    this.oauth2Service.startAuthorization().catch(error => {\\r\\n      console.error('Retry login error:', error);\\r\\n      this.isLoading = false;\\r\\n      this.error = 'Failed to start authentication';\\r\\n    });\\r\\n  }\\r\\n\\r\\n  goHome(): void {\\r\\n    this.router.navigate(['/']);\\r\\n  }\\r\\n}\",\"import { inject } from '@angular/core';\\r\\nimport { Router, CanActivateFn, ActivatedRouteSnapshot, RouterStateSnapshot } from '@angular/router';\\r\\nimport { Observable, of } from 'rxjs';\\r\\nimport { map, take } from 'rxjs/operators';\\r\\nimport { OAuth2Service } from '../services/oauth2.service';\\r\\n\\r\\n/**\\r\\n * OAuth2 Authentication Guard Function\\r\\n * Protects routes by checking if user is authenticated\\r\\n */\\r\\nexport const oauth2AuthGuard: CanActivateFn = (\\r\\n  route: ActivatedRouteSnapshot,\\r\\n  state: RouterStateSnapshot\\r\\n): Observable<boolean> | Promise<boolean> | boolean => {\\r\\n  const oauth2Service = inject(OAuth2Service);\\r\\n  const router = inject(Router);\\r\\n\\r\\n  // Check if authentication is available in current environment\\r\\n  if (!oauth2Service.isAuthenticationAvailable()) {\\r\\n    console.warn('[OAuth2AuthGuard] Authentication not available in current environment');\\r\\n    return false;\\r\\n  }\\r\\n\\r\\n  // Check current authentication state\\r\\n  return oauth2Service.authState$.pipe(\\r\\n    take(1),\\r\\n    map(authState => {\\r\\n      if (authState.isAuthenticated) {\\r\\n        return true;\\r\\n      }\\r\\n\\r\\n      // Check if we have stored tokens that might be valid\\r\\n      if (oauth2Service.isAuthenticated()) {\\r\\n        return true;\\r\\n      }\\r\\n\\r\\n      // User is not authenticated, redirect to login or start OAuth flow\\r\\n      console.log('[OAuth2AuthGuard] User not authenticated, starting OAuth2 flow');\\r\\n      \\r\\n      // You can customize this behavior:\\r\\n      // Option 1: Start OAuth2 flow immediately\\r\\n      oauth2Service.startAuthorization().catch(error => {\\r\\n        console.error('[OAuth2AuthGuard] Failed to start OAuth2 flow:', error);\\r\\n      });\\r\\n      \\r\\n      // Option 2: Redirect to a login page\\r\\n      // router.navigate(['/login'], { queryParams: { returnUrl: state.url } });\\r\\n      \\r\\n      return false;\\r\\n    })\\r\\n  );\\r\\n};\\r\\n\\r\\n/**\\r\\n * OAuth2 Authentication Guard Class (for backward compatibility)\\r\\n * @deprecated Use oauth2AuthGuard function instead\\r\\n */\\r\\nexport class OAuth2AuthGuard {\\r\\n  constructor(\\r\\n    private oauth2Service: OAuth2Service,\\r\\n    private router: Router\\r\\n  ) {}\\r\\n\\r\\n  canActivate(\\r\\n    route: ActivatedRouteSnapshot,\\r\\n    state: RouterStateSnapshot\\r\\n  ): Observable<boolean> | Promise<boolean> | boolean {\\r\\n    // Check if authentication is available in current environment\\r\\n    if (!this.oauth2Service.isAuthenticationAvailable()) {\\r\\n      console.warn('[OAuth2AuthGuard] Authentication not available in current environment');\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    // Check current authentication state\\r\\n    return this.oauth2Service.authState$.pipe(\\r\\n      take(1),\\r\\n      map(authState => {\\r\\n        if (authState.isAuthenticated) {\\r\\n          return true;\\r\\n        }\\r\\n\\r\\n        // Check if we have stored tokens that might be valid\\r\\n        if (this.oauth2Service.isAuthenticated()) {\\r\\n          return true;\\r\\n        }\\r\\n\\r\\n        // User is not authenticated, redirect to login or start OAuth flow\\r\\n        console.log('[OAuth2AuthGuard] User not authenticated, starting OAuth2 flow');\\r\\n        \\r\\n        this.oauth2Service.startAuthorization().catch(error => {\\r\\n          console.error('[OAuth2AuthGuard] Failed to start OAuth2 flow:', error);\\r\\n        });\\r\\n        \\r\\n        return false;\\r\\n      })\\r\\n    );\\r\\n  }\\r\\n}\\r\\n\\r\\n/**\\r\\n * OAuth2 Unauthenticated Guard Function\\r\\n * Protects routes that should only be accessible to unauthenticated users\\r\\n * (e.g., login page, registration page)\\r\\n */\\r\\nexport const oauth2UnauthGuard: CanActivateFn = (\\r\\n  route: ActivatedRouteSnapshot,\\r\\n  state: RouterStateSnapshot\\r\\n): Observable<boolean> | Promise<boolean> | boolean => {\\r\\n  const oauth2Service = inject(OAuth2Service);\\r\\n  const router = inject(Router);\\r\\n\\r\\n  // Check if authentication is available in current environment\\r\\n  if (!oauth2Service.isAuthenticationAvailable()) {\\r\\n    return true; // Allow access if auth is not available\\r\\n  }\\r\\n\\r\\n  // Check current authentication state\\r\\n  return oauth2Service.authState$.pipe(\\r\\n    take(1),\\r\\n    map(authState => {\\r\\n      if (!authState.isAuthenticated && !oauth2Service.isAuthenticated()) {\\r\\n        return true; // User is not authenticated, allow access\\r\\n      }\\r\\n\\r\\n      // User is authenticated, redirect to protected area\\r\\n      console.log('[OAuth2UnauthGuard] User already authenticated, redirecting');\\r\\n      router.navigate(['/']); // Redirect to home or dashboard\\r\\n      return false;\\r\\n    })\\r\\n  );\\r\\n};\\r\\n\\r\\n/**\\r\\n * OAuth2 Role Guard Function\\r\\n * Protects routes based on user roles or permissions\\r\\n */\\r\\nexport interface OAuth2RoleGuardConfig {\\r\\n  roles?: string[];\\r\\n  permissions?: string[];\\r\\n  requireAll?: boolean; // If true, user must have ALL roles/permissions. If false, user needs ANY.\\r\\n}\\r\\n\\r\\nexport function oauth2RoleGuard(config: OAuth2RoleGuardConfig): CanActivateFn {\\r\\n  return (route: ActivatedRouteSnapshot, state: RouterStateSnapshot): Observable<boolean> | Promise<boolean> | boolean => {\\r\\n    const oauth2Service = inject(OAuth2Service);\\r\\n    const router = inject(Router);\\r\\n\\r\\n    // First check if user is authenticated\\r\\n    if (!oauth2Service.isAuthenticated()) {\\r\\n      console.log('[OAuth2RoleGuard] User not authenticated');\\r\\n      oauth2Service.startAuthorization().catch(error => {\\r\\n        console.error('[OAuth2RoleGuard] Failed to start OAuth2 flow:', error);\\r\\n      });\\r\\n      return false;\\r\\n    }\\r\\n\\r\\n    // If no roles or permissions specified, just check authentication\\r\\n    if (!config.roles?.length && !config.permissions?.length) {\\r\\n      return true;\\r\\n    }\\r\\n\\r\\n    // Get user info to check roles/permissions\\r\\n    return oauth2Service.getUserInfo().then(userInfo => {\\r\\n      const userRoles = (userInfo as any).roles || [];\\r\\n      const userPermissions = (userInfo as any).permissions || [];\\r\\n\\r\\n      let hasRequiredRoles = true;\\r\\n      let hasRequiredPermissions = true;\\r\\n\\r\\n      // Check roles\\r\\n      if (config.roles?.length) {\\r\\n        if (config.requireAll) {\\r\\n          hasRequiredRoles = config.roles.every(role => userRoles.includes(role));\\r\\n        } else {\\r\\n          hasRequiredRoles = config.roles.some(role => userRoles.includes(role));\\r\\n        }\\r\\n      }\\r\\n\\r\\n      // Check permissions\\r\\n      if (config.permissions?.length) {\\r\\n        if (config.requireAll) {\\r\\n          hasRequiredPermissions = config.permissions.every(permission => userPermissions.includes(permission));\\r\\n        } else {\\r\\n          hasRequiredPermissions = config.permissions.some(permission => userPermissions.includes(permission));\\r\\n        }\\r\\n      }\\r\\n\\r\\n      const hasAccess = hasRequiredRoles && hasRequiredPermissions;\\r\\n\\r\\n      if (!hasAccess) {\\r\\n        console.warn('[OAuth2RoleGuard] User does not have required roles/permissions');\\r\\n        router.navigate(['/unauthorized']); // Redirect to unauthorized page\\r\\n      }\\r\\n\\r\\n      return hasAccess;\\r\\n    }).catch(error => {\\r\\n      console.error('[OAuth2RoleGuard] Failed to get user info:', error);\\r\\n      return false;\\r\\n    });\\r\\n  };\\r\\n}\",\"import { EnvironmentProviders, makeEnvironmentProviders } from '@angular/core';\\r\\nimport { provideHttpClient, withInterceptors } from '@angular/common/http';\\r\\nimport { OAuth2Config } from './models/oauth2-config.model';\\r\\nimport { OAUTH2_CONFIG_TOKEN } from './tokens/oauth2-config.token';\\r\\nimport { OAuth2Service } from './services/oauth2.service';\\r\\nimport { OAuth2StorageService } from './services/oauth2-storage.service';\\r\\nimport { oauth2InterceptorFn } from './interceptors/oauth2.interceptor';\\r\\n\\r\\n/**\\r\\n * Provide OAuth2 configuration and services\\r\\n * Use this function in your app.config.ts or main.ts\\r\\n */\\r\\nexport function provideOAuth2(config: OAuth2Config): EnvironmentProviders {\\r\\n  return makeEnvironmentProviders([\\r\\n    // Provide the OAuth2 configuration\\r\\n    { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\\r\\n    \\r\\n    // Provide the OAuth2 services\\r\\n    OAuth2Service,\\r\\n    OAuth2StorageService,\\r\\n    \\r\\n    // Provide HTTP client with OAuth2 interceptor\\r\\n    provideHttpClient(\\r\\n      withInterceptors([oauth2InterceptorFn])\\r\\n    )\\r\\n  ]);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Provide OAuth2 configuration and services without HTTP interceptor\\r\\n * Use this if you want to manually configure the HTTP interceptor\\r\\n */\\r\\nexport function provideOAuth2WithoutInterceptor(config: OAuth2Config): EnvironmentProviders {\\r\\n  return makeEnvironmentProviders([\\r\\n    // Provide the OAuth2 configuration\\r\\n    { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\\r\\n    \\r\\n    // Provide the OAuth2 services\\r\\n    OAuth2Service,\\r\\n    OAuth2StorageService\\r\\n  ]);\\r\\n}\\r\\n\\r\\n/**\\r\\n * Legacy NgModule for backward compatibility\\r\\n * @deprecated Use provideOAuth2() function instead\\r\\n */\\r\\nimport { NgModule, ModuleWithProviders } from '@angular/core';\\r\\nimport { CommonModule } from '@angular/common';\\r\\n\\r\\n@NgModule({\\r\\n  imports: [CommonModule],\\r\\n  exports: []\\r\\n})\\r\\nexport class NgOAuth2PkceModule {\\r\\n  static forRoot(config: OAuth2Config): ModuleWithProviders<NgOAuth2PkceModule> {\\r\\n    return {\\r\\n      ngModule: NgOAuth2PkceModule,\\r\\n      providers: [\\r\\n        { provide: OAUTH2_CONFIG_TOKEN, useValue: config },\\r\\n        OAuth2Service,\\r\\n        OAuth2StorageService\\r\\n      ]\\r\\n    };\\r\\n  }\\r\\n}\",\"/*\\r\\n * Public API Surface of ng-oauth2-pkce\\r\\n */\\r\\n\\r\\n// Export models\\r\\nexport * from './lib/models/oauth2-config.model';\\r\\nexport * from './lib/models/oauth2-types.model';\\r\\n\\r\\n// Export services\\r\\nexport * from './lib/services/oauth2.service';\\r\\nexport * from './lib/services/oauth2-storage.service';\\r\\n\\r\\n// Export interceptors\\r\\nexport * from './lib/interceptors/oauth2.interceptor';\\r\\n\\r\\n// Export components\\r\\nexport * from './lib/components/oauth2-callback/oauth2-callback.component';\\r\\n\\r\\n// Export guards\\r\\nexport * from './lib/guards/oauth2-auth.guard';\\r\\n\\r\\n// Export tokens\\r\\nexport * from './lib/tokens/oauth2-config.token';\\r\\n\\r\\n// Export main module and providers\\r\\nexport * from './lib/ng-oauth2-pkce.service';\",\"/**\\n * Generated bundle index. Do not edit.\\n */\\n\\nexport * from './public-api';\\n\"],\"names\":[\"i3.OAuth2StorageService\"],\"mappings\":\"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\"}","type":"asset"}]}